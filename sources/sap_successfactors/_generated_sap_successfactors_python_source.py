# ==============================================================================
# Merged Lakeflow Source: sap_successfactors
# ==============================================================================
# This file is auto-generated by tools/scripts/merge_python_source.py
# Do not edit manually. Make changes to the source files instead.
# ==============================================================================

from datetime import datetime
from decimal import Decimal
from typing import Any, Iterator
import json

from pyspark.sql import Row
from pyspark.sql.datasource import DataSource, DataSourceReader, SimpleDataSourceStreamReader
from pyspark.sql.types import *
import base64


def register_lakeflow_source(spark):
    """Register the Lakeflow Python source with Spark."""

    ########################################################
    # libs/utils.py
    ########################################################

    def _parse_struct(value: Any, field_type: StructType) -> Row:
        """Parse a dictionary into a PySpark Row based on StructType schema."""
        if not isinstance(value, dict):
            raise ValueError(f"Expected a dictionary for StructType, got {type(value)}")
        # Spark Python -> Arrow conversion require missing StructType fields to be assigned None.
        if value == {}:
            raise ValueError(
                "field in StructType cannot be an empty dict. "
                "Please assign None as the default value instead."
            )
        field_dict = {}
        for field in field_type.fields:
            if field.name in value:
                field_dict[field.name] = parse_value(value.get(field.name), field.dataType)
            elif field.nullable:
                field_dict[field.name] = None
            else:
                raise ValueError(f"Field {field.name} is not nullable but not found in the input")
        return Row(**field_dict)


    def _parse_array(value: Any, field_type: ArrayType) -> list:
        """Parse a list into a PySpark array based on ArrayType schema."""
        if not isinstance(value, list):
            if field_type.containsNull:
                return [parse_value(value, field_type.elementType)]
            raise ValueError(f"Expected a list for ArrayType, got {type(value)}")
        return [parse_value(v, field_type.elementType) for v in value]


    def _parse_map(value: Any, field_type: MapType) -> dict:
        """Parse a dictionary into a PySpark map based on MapType schema."""
        if not isinstance(value, dict):
            raise ValueError(f"Expected a dictionary for MapType, got {type(value)}")
        return {
            parse_value(k, field_type.keyType): parse_value(v, field_type.valueType)
            for k, v in value.items()
        }


    def _parse_string(value: Any) -> str:
        """Convert value to string."""
        return str(value)


    def _parse_integer(value: Any) -> int:
        """Convert value to integer."""
        if isinstance(value, str) and value.strip():
            return int(float(value)) if "." in value else int(value)
        if isinstance(value, (int, float)):
            return int(value)
        raise ValueError(f"Cannot convert {value} to integer")


    def _parse_float(value: Any) -> float:
        """Convert value to float."""
        return float(value)


    def _parse_decimal(value: Any) -> Decimal:
        """Convert value to Decimal."""
        return Decimal(value) if isinstance(value, str) and value.strip() else Decimal(str(value))


    def _parse_boolean(value: Any) -> bool:
        """Convert value to boolean."""
        if isinstance(value, str):
            lowered = value.lower()
            if lowered in ("true", "t", "yes", "y", "1"):
                return True
            if lowered in ("false", "f", "no", "n", "0"):
                return False
        return bool(value)


    def _parse_date(value: Any) -> datetime.date:
        """Convert value to date."""
        if isinstance(value, str):
            for fmt in ("%Y-%m-%d", "%m/%d/%Y", "%d-%m-%Y", "%Y/%m/%d"):
                try:
                    return datetime.strptime(value, fmt).date()
                except ValueError:
                    continue
            return datetime.fromisoformat(value).date()
        if isinstance(value, datetime):
            return value.date()
        raise ValueError(f"Cannot convert {value} to date")


    def _parse_timestamp(value: Any) -> datetime:
        """Convert value to timestamp."""
        if isinstance(value, str):
            ts_value = value.replace("Z", "+00:00") if value.endswith("Z") else value
            try:
                return datetime.fromisoformat(ts_value)
            except ValueError:
                for fmt in ("%Y-%m-%d %H:%M:%S", "%Y/%m/%d %H:%M:%S"):
                    try:
                        return datetime.strptime(ts_value, fmt)
                    except ValueError:
                        continue
        elif isinstance(value, (int, float)):
            return datetime.fromtimestamp(value)
        elif isinstance(value, datetime):
            return value
        raise ValueError(f"Cannot convert {value} to timestamp")


    def _decode_string_to_bytes(value: str) -> bytes:
        """Try to decode a string as base64, then hex, then UTF-8."""
        try:
            return base64.b64decode(value)
        except Exception:
            pass
        try:
            return bytes.fromhex(value)
        except Exception:
            pass
        return value.encode("utf-8")


    def _parse_binary(value: Any) -> bytes:
        """Convert value to bytes. Tries base64, then hex, then UTF-8 for strings."""
        if isinstance(value, bytes):
            return value
        if isinstance(value, bytearray):
            return bytes(value)
        if isinstance(value, str):
            return _decode_string_to_bytes(value)
        if isinstance(value, list):
            return bytes(value)
        return str(value).encode("utf-8")


    # Mapping of primitive types to their parser functions
    _PRIMITIVE_PARSERS = {
        StringType: _parse_string,
        IntegerType: _parse_integer,
        LongType: _parse_integer,
        FloatType: _parse_float,
        DoubleType: _parse_float,
        DecimalType: _parse_decimal,
        BooleanType: _parse_boolean,
        DateType: _parse_date,
        TimestampType: _parse_timestamp,
        BinaryType: _parse_binary,
    }


    def parse_value(value: Any, field_type: DataType) -> Any:
        """
        Converts a JSON value into a PySpark-compatible data type based on the provided field type.
        """
        if value is None:
            return None

        # Handle complex types
        if isinstance(field_type, StructType):
            return _parse_struct(value, field_type)
        if isinstance(field_type, ArrayType):
            return _parse_array(value, field_type)
        if isinstance(field_type, MapType):
            return _parse_map(value, field_type)

        # Handle primitive types via type-based lookup
        try:
            field_type_class = type(field_type)
            if field_type_class in _PRIMITIVE_PARSERS:
                return _PRIMITIVE_PARSERS[field_type_class](value)

            # Check for custom UDT handling
            if hasattr(field_type, "fromJson"):
                return field_type.fromJson(value)

            raise TypeError(f"Unsupported field type: {field_type}")
        except (ValueError, TypeError) as e:
            raise ValueError(f"Error converting '{value}' ({type(value)}) to {field_type}: {str(e)}")


    ########################################################
    # sources/sap_successfactors/sap_successfactors.py
    ########################################################

    SAP SuccessFactors Connector for Lakeflow Community Connectors.

    This connector implements the LakeflowConnect interface for SAP SuccessFactors,
    supporting OData v2, OData v4, REST, and SCIM 2.0 APIs.

    Supports ~550 entities across modules:
    - Employee Central (Core & Extended)
    - Platform Services
    - Recruiting
    - Performance & Goals
    - Time & Attendance
    - Succession & Development
    - Onboarding
    - Finance & Operations
    """

    import base64
    import time
    import logging
    from datetime import datetime
    from typing import Iterator, Dict, List, Any, Optional, Tuple
    import requests
    from pyspark.sql.types import (
        StructType, StructField, StringType, LongType, IntegerType,
        DoubleType, BooleanType, TimestampType, DateType, DecimalType,
        ArrayType, MapType
    )

    logger = logging.getLogger(__name__)


    class LakeflowConnect:
        """SAP SuccessFactors connector implementing the LakeflowConnect interface."""

        # ==========================================================================
        # Entity Registry: Metadata for all ~550 supported entities
        # Organized by module for easier maintenance
        # ==========================================================================

        _ENTITY_REGISTRY: Dict[str, Dict[str, Any]] = {}

        @classmethod
        def _build_entity_registry(cls) -> Dict[str, Dict[str, Any]]:
            """Build the entity registry with all ~550 entities."""
            registry = {}

            # ======================================================================
            # Employee Central Core (OData v2)
            # ======================================================================
            ec_core = {
                "User": {"pks": ["userId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "EmpEmployment": {"pks": ["personIdExternal", "userId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "EmpJob": {"pks": ["seqNumber", "startDate", "userId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "EmpCompensation": {"pks": ["seqNumber", "startDate", "userId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "EmpJobRelationships": {"pks": ["seqNumber", "startDate", "userId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "EmpWorkPermit": {"pks": ["seqNumber", "startDate", "userId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "EmpGlobalAssignment": {"pks": ["seqNumber", "startDate", "userId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "EmpPayCompRecurring": {"pks": ["seqNumber", "startDate", "userId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "EmpPayCompNonRecurring": {"pks": ["seqNumber", "startDate", "userId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "EmpCostAssignment": {"pks": ["effectiveStartDate", "worker"], "cursor": "lastModifiedDateTime", "ing": "cdc_with_deletes", "soft_delete": True},
                "PerPerson": {"pks": ["personIdExternal"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "PerPersonal": {"pks": ["personIdExternal", "startDate"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "PerEmail": {"pks": ["personIdExternal", "emailType"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "PerPhone": {"pks": ["personIdExternal", "phoneType"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "PerAddressDEFLT": {"pks": ["personIdExternal", "addressType", "startDate"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "PerEmergencyContacts": {"pks": ["personIdExternal", "name"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "PerNationalId": {"pks": ["personIdExternal", "country", "cardType"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "EmpEmploymentTermination": {"pks": ["personIdExternal", "userId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
            }
            for name, cfg in ec_core.items():
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": cfg["pks"], "cursor_field": cfg["cursor"],
                    "ingestion_type": cfg["ing"], "module": "employee_central",
                    "soft_delete_field": "mdfSystemRecordStatus" if cfg.get("soft_delete") else None,
                    "soft_delete_value": "D" if cfg.get("soft_delete") else None,
                }

            # ======================================================================
            # Foundation Objects (OData v2)
            # ======================================================================
            fo_objects = [
                "FODepartment", "FOCompany", "FOCostCenter", "FOJobCode", "FOLocation",
                "FOBusinessUnit", "FODivision", "FOEventReason", "FOFrequency",
                "FOGeozoneMapping", "FOGlobalOrganization", "FOJobFunction", "FOJobClassLocalDEFLT",
                "FOLegalEntityLocalDEFLT", "FOPayComponent", "FOPayComponentGroup", "FOPayGrade",
                "FOPayGroup", "FOPayRange", "FOPayrollEntity", "FOWfConfig", "FOCorporateAddressDEFLT",
            ]
            for name in fo_objects:
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": ["externalCode", "startDate"], "cursor_field": "lastModifiedDateTime",
                    "ingestion_type": "cdc", "module": "employee_central",
                }

            # Single-key FO objects
            fo_single_key = ["Position", "JobClassificationCountry", "JobClassificationMethod"]
            for name in fo_single_key:
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": ["code" if name == "Position" else "externalCode"],
                    "cursor_field": "lastModifiedDateTime", "ingestion_type": "cdc",
                    "module": "employee_central",
                }

            # ======================================================================
            # Employee Central Extended - Payment Information (OData v2)
            # ======================================================================
            payment_entities = [
                "PaymentInformationV3", "PaymentInformationDetailV3",
                "Bank", "BankBranch", "Currency", "PayCalendar", "PayPeriod",
                "CustomPayType", "CustomPayTypeAssignment",
            ]
            for name in payment_entities:
                pks = ["externalCode"] if name != "PaymentInformationDetailV3" else ["PaymentInformationV3_effectiveStartDate", "PaymentInformationV3_worker", "externalCode"]
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": pks, "cursor_field": "lastModifiedDateTime",
                    "ingestion_type": "cdc", "module": "employee_central",
                }

            # Country-specific payment entities (most common)
            payment_countries = ["USA", "DEU", "GBR", "FRA", "CAN", "AUS", "IND", "JPN", "CHN", "BRA", "MEX"]
            for country in payment_countries:
                name = f"PaymentInformationDetailV3{country}"
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": ["PaymentInformationDetailV3_PaymentInformationV3_effectiveStartDate",
                                     "PaymentInformationDetailV3_PaymentInformationV3_worker",
                                     "PaymentInformationDetailV3_externalCode", "externalCode"],
                    "cursor_field": "lastModifiedDateTime", "ingestion_type": "cdc",
                    "module": "employee_central",
                }

            # ======================================================================
            # Platform Services (OData v2)
            # ======================================================================
            platform_entities = {
                "PickList": {"pks": ["picklistId"], "cursor": "lastModifiedDateTime"},
                "PickListV2": {"pks": ["PickListV2_id"], "cursor": "lastModifiedDateTime"},
                "PicklistOption": {"pks": ["id"], "cursor": "lastModifiedDateTime"},
                "PicklistLabel": {"pks": ["locale", "optionId"], "cursor": "lastModifiedDateTime"},
                "DynamicGroup": {"pks": ["groupID"], "cursor": "lastModifiedDateTime"},
                "DynamicGroupBean": {"pks": ["beanID"], "cursor": "lastModifiedDateTime"},
                "TodoEntryV3": {"pks": ["todoEntryId"], "cursor": "lastModifiedDateTime"},
                "TodoAction": {"pks": ["actionId"], "cursor": "lastModifiedDateTime"},
                "Attachment": {"pks": ["attachmentId"], "cursor": "lastModifiedDateTime"},
                "Photo": {"pks": ["photoType", "userId"], "cursor": "lastModifiedDateTime"},
                "TimeZone": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "Country": {"pks": ["code"], "cursor": "lastModifiedDateTime"},
                "WfRequest": {"pks": ["wfRequestId"], "cursor": "lastModifiedOn"},
                "WfRequestStep": {"pks": ["wfRequestStepId"], "cursor": "lastModifiedOn"},
                "WfRequestComments": {"pks": ["wfRequestCommentId"], "cursor": "lastModifiedOn"},
                "WfRequestUIData": {"pks": ["wfRequestId"], "cursor": "lastModifiedOn"},
                "MessageDetail": {"pks": ["code"], "cursor": "lastModifiedDateTime"},
                "SecondaryAssignment": {"pks": ["effectiveStartDate", "externalCode"], "cursor": "lastModifiedDateTime", "ing": "cdc_with_deletes"},
                "SecondaryAssignmentsItem": {"pks": ["SecondaryAssignment_effectiveStartDate", "SecondaryAssignment_externalCode", "externalCode"], "cursor": "lastModifiedDateTime"},
            }
            for name, cfg in platform_entities.items():
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": cfg["pks"], "cursor_field": cfg["cursor"],
                    "ingestion_type": cfg.get("ing", "cdc"), "module": "platform",
                    "soft_delete_field": "mdfSystemRecordStatus" if cfg.get("ing") == "cdc_with_deletes" else None,
                    "soft_delete_value": "D" if cfg.get("ing") == "cdc_with_deletes" else None,
                }

            # ======================================================================
            # Recruiting (OData v2)
            # ======================================================================
            recruiting_entities = {
                "Candidate": {"pks": ["candidateId"], "cursor": "lastModifiedDateTime"},
                "CandidateLight": {"pks": ["candidateId"], "cursor": "lastModifiedDateTime"},
                "CandidateBackground_Certificates": {"pks": ["backgroundElementId"], "cursor": "lastModifiedDateTime"},
                "CandidateBackground_Education": {"pks": ["backgroundElementId"], "cursor": "lastModifiedDateTime"},
                "CandidateBackground_InsideWorkExperience": {"pks": ["backgroundElementId"], "cursor": "lastModifiedDateTime"},
                "CandidateBackground_Languages": {"pks": ["backgroundElementId"], "cursor": "lastModifiedDateTime"},
                "CandidateBackground_Mobility": {"pks": ["backgroundElementId"], "cursor": "lastModifiedDateTime"},
                "CandidateBackground_OutsideWorkExperience": {"pks": ["backgroundElementId"], "cursor": "lastModifiedDateTime"},
                "CandidateBackground_TalentPool": {"pks": ["backgroundElementId"], "cursor": "lastModifiedDateTime"},
                "CandidateBackground_TalentPoolcorp": {"pks": ["backgroundElementId"], "cursor": "lastModifiedDateTime"},
                "CandidateProfileConversionInfo": {"pks": ["candidateId"], "cursor": "lastModifiedDateTime"},
                "CandidateProfileExtension": {"pks": ["candidateId"], "cursor": "lastModifiedDateTime"},
                "CandidateTags": {"pks": ["tagId"], "cursor": "lastModifiedDateTime"},
                "CandidateComments": {"pks": ["commentId"], "cursor": "lastModifiedDateTime"},
                "JobApplication": {"pks": ["applicationId"], "cursor": "lastModifiedDateTime"},
                "JobApplicationSnapshot_Certificates": {"pks": ["backgroundElementId"], "cursor": "lastModifiedDateTime"},
                "JobApplicationSnapshot_Education": {"pks": ["backgroundElementId"], "cursor": "lastModifiedDateTime"},
                "JobApplicationSnapshot_InsideWorkExperience": {"pks": ["backgroundElementId"], "cursor": "lastModifiedDateTime"},
                "JobApplicationSnapshot_Languages": {"pks": ["backgroundElementId"], "cursor": "lastModifiedDateTime"},
                "JobApplicationSnapshot_Mobility": {"pks": ["backgroundElementId"], "cursor": "lastModifiedDateTime"},
                "JobApplicationSnapshot_OutsideWorkExperience": {"pks": ["backgroundElementId"], "cursor": "lastModifiedDateTime"},
                "JobApplicationSnapshot_TalentPool": {"pks": ["backgroundElementId"], "cursor": "lastModifiedDateTime"},
                "JobApplicationSnapshot_TalentPoolcorp": {"pks": ["backgroundElementId"], "cursor": "lastModifiedDateTime"},
                "JobApplicationComments": {"pks": ["commentId"], "cursor": "lastModifiedDateTime"},
                "JobApplicationInterview": {"pks": ["applicationInterviewId"], "cursor": "lastModifiedDateTime"},
                "JobApplicationInterviewFieldControls": {"pks": ["applicationInterviewId"], "cursor": "lastModifiedDateTime"},
                "JobApplicationOnboardingData": {"pks": ["applicationId"], "cursor": "lastModifiedDateTime"},
                "JobApplicationOnboardingStatus": {"pks": ["applicationId"], "cursor": "lastModifiedDateTime"},
                "JobApplicationAudit": {"pks": ["revNumber", "applicationId"], "cursor": "lastModifiedDateTime"},
                "JobApplicationStatusAuditTrail": {"pks": ["revNumber"], "cursor": "createdDate"},
                "JobRequisition": {"pks": ["jobReqId"], "cursor": "lastModifiedDateTime", "ing": "cdc_with_deletes"},
                "JobRequisitionLocale": {"pks": ["jobReqLocalId"], "cursor": "lastModifiedDateTime"},
                "JobRequisitionFieldControls": {"pks": ["jobReqId"], "cursor": "lastModifiedDateTime"},
                "JobRequisitionOperator": {"pks": ["jobReqId", "operatorRole"], "cursor": "lastModifiedDateTime"},
                "JobRequisitionPosting": {"pks": ["jobPostingId"], "cursor": "lastModifiedDateTime"},
                "JobRequisitionAssessment": {"pks": ["jobReqId"], "cursor": "lastModifiedDateTime"},
                "JobOffer": {"pks": ["offerApprovalId"], "cursor": "lastModifiedDateTime"},
                "JobOfferApprover": {"pks": ["offerApprovalId", "offerApproverId"], "cursor": "lastModifiedDateTime"},
                "JobOfferFieldControls": {"pks": ["offerApprovalId"], "cursor": "lastModifiedDateTime"},
                "JobOfferTemplate_Offer_Detail": {"pks": ["templateId"], "cursor": "lastModifiedDateTime"},
                "JobOfferTemplate_Standard_Offer": {"pks": ["templateId"], "cursor": "lastModifiedDateTime"},
                "OfferLetter": {"pks": ["offerApprovalId"], "cursor": "lastModifiedDateTime"},
                "InterviewOverallAssessment": {"pks": ["interviewOverallAssessmentId"], "cursor": "lastModifiedDateTime"},
                "RCMCompetency": {"pks": ["competencyId"], "cursor": "lastModifiedDateTime"},
                "RCMAdminReassignOfferApprover": {"pks": ["offerId"], "cursor": "lastModifiedDateTime"},
            }
            for name, cfg in recruiting_entities.items():
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": cfg["pks"], "cursor_field": cfg["cursor"],
                    "ingestion_type": cfg.get("ing", "cdc"), "module": "recruiting",
                    "soft_delete_field": "status" if name == "JobRequisition" else None,
                    "soft_delete_value": "Closed" if name == "JobRequisition" else None,
                }

            # ======================================================================
            # Performance & Goals (OData v2)
            # ======================================================================
            # Goal entities (Goal_1 through Goal_8 for different plan types)
            for i in range(1, 9):
                name = f"Goal_{i}"
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": ["id"], "cursor_field": "lastModified",
                    "ingestion_type": "cdc_with_deletes", "module": "performance",
                    "soft_delete_field": "state", "soft_delete_value": "deleted",
                }
                # Goal tasks and related entities
                for suffix in ["Task", "Metric", "Target", "AchievementsList", "AchievementsItem"]:
                    task_name = f"Goal{suffix}_{i}"
                    registry[task_name] = {
                        "api_type": "odata_v2", "path": f"/odata/v2/{task_name}",
                        "primary_keys": ["id"], "cursor_field": "lastModified",
                        "ingestion_type": "cdc", "module": "performance",
                    }

            # Simple goal entities without number suffix
            simple_goal = ["SimpleGoal", "DevGoal", "DevGoalCompetency", "DevGoalDetail",
                           "DevGoalPlanTemplate", "DevGoalTask", "DevGoalEnum"]
            for name in simple_goal:
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": ["id"], "cursor_field": "lastModified",
                    "ingestion_type": "cdc", "module": "performance",
                }

            # Goal plan and template entities
            goal_plan_entities = ["GoalPlanState", "GoalPlanTemplate", "GoalWeight"]
            for name in goal_plan_entities:
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": ["id"], "cursor_field": "lastModified",
                    "ingestion_type": "cdc", "module": "performance",
                }

            # Performance form entities
            perf_form_entities = {
                "FormHeader": {"pks": ["formDataId"], "cursor": "lastModifiedDateTime"},
                "FormContent": {"pks": ["formContentId"], "cursor": "lastModifiedDateTime"},
                "FormFolder": {"pks": ["folderId"], "cursor": "lastModifiedDateTime"},
                "FormSubject": {"pks": ["formSubjectId"], "cursor": "lastModifiedDateTime"},
                "FormPerfPotSummary": {"pks": ["formContentId", "formDataId", "sectionIndex"], "cursor": "lastModifiedDateTime"},
                "FormObjective": {"pks": ["formContentId", "formDataId", "itemId", "sectionIndex"], "cursor": "lastModifiedDateTime"},
                "FormObjectiveComment": {"pks": ["formContentId", "formDataId", "itemId", "sectionIndex", "userId"], "cursor": "lastModifiedDateTime"},
                "FormObjectiveOtherDetails": {"pks": ["formContentId", "formDataId", "itemId", "sectionIndex"], "cursor": "lastModifiedDateTime"},
                "FormCustomElement": {"pks": ["elementKey", "formContentId", "formDataId", "sectionIndex"], "cursor": "lastModifiedDateTime"},
                "FormRatingScale": {"pks": ["formContentId", "formDataId", "sectionIndex", "scaleId"], "cursor": "lastModifiedDateTime"},
                "FormRatingScaleValue": {"pks": ["formContentId", "formDataId", "scaleId", "scaleIndex", "sectionIndex"], "cursor": "lastModifiedDateTime"},
                "FormReviewerInfoSection": {"pks": ["formContentId", "formDataId", "sectionIndex"], "cursor": "lastModifiedDateTime"},
                "FormReviewFeedback": {"pks": ["formContentId", "formDataId", "formReviewFeedbackId", "sectionIndex"], "cursor": "lastModifiedDateTime"},
                "FormReviewFeedbackList": {"pks": ["formContentId", "formDataId", "sectionIndex"], "cursor": "lastModifiedDateTime"},
                "FormSectionConfiguration": {"pks": ["formContentId", "formDataId", "sectionIndex"], "cursor": "lastModifiedDateTime"},
                "FormSectionComment": {"pks": ["formContentId", "formDataId", "sectionIndex", "userId"], "cursor": "lastModifiedDateTime"},
                "FormSummarySection": {"pks": ["formContentId", "formDataId", "sectionIndex"], "cursor": "lastModifiedDateTime"},
                "FormUserInformationSection": {"pks": ["formContentId", "formDataId", "sectionIndex"], "cursor": "lastModifiedDateTime"},
                "FormAuditTrail": {"pks": ["auditTrailId"], "cursor": "lastModifiedDateTime"},
                "FormIntroductionSection": {"pks": ["formContentId", "formDataId", "sectionIndex"], "cursor": "lastModifiedDateTime"},
                "FormJobRole": {"pks": ["formContentId", "formDataId", "sectionIndex"], "cursor": "lastModifiedDateTime"},
                "FormRouteMap": {"pks": ["formDataId"], "cursor": "lastModifiedDateTime"},
                "FormRouteSubStep": {"pks": ["formDataId", "stepOrder"], "cursor": "lastModifiedDateTime"},
                "FormSignature": {"pks": ["formDataId", "signatureOrder"], "cursor": "lastModifiedDateTime"},
                "FormSignatureSection": {"pks": ["formContentId", "formDataId", "sectionIndex"], "cursor": "lastModifiedDateTime"},
                "FormTemplate": {"pks": ["formTemplateId"], "cursor": "lastModifiedDateTime"},
                "PMReviewerInfoSectionConfig": {"pks": ["formReviewerInfoSectionConfigId"], "cursor": "lastModifiedDateTime"},
                "PerformanceReviewContent": {"pks": ["formContentId", "formDataId"], "cursor": "lastModifiedDateTime"},
                "PerformanceReviewContentDetail": {"pks": ["formContentId", "formDataId"], "cursor": "lastModifiedDateTime"},
            }
            for name, cfg in perf_form_entities.items():
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": cfg["pks"], "cursor_field": cfg["cursor"],
                    "ingestion_type": "cdc", "module": "performance",
                }

            # CPM (Continuous Performance Management) entities
            cpm_entities = {
                "Achievement": {"pks": ["achievementId"], "ing": "cdc_with_deletes"},
                "AchievementDevGoalDetail": {"pks": ["Achievement_achievementId", "externalCode"], "ing": "cdc"},
                "AchievementGoalDetail": {"pks": ["Achievement_achievementId", "externalCode"], "ing": "cdc"},
                "Activity": {"pks": ["activityId"], "ing": "cdc_with_deletes"},
                "ActivityFeedback": {"pks": ["Activity_activityId", "feedbackId"], "ing": "cdc"},
                "ActivityStatus": {"pks": ["externalCode"], "ing": "cdc"},
                "Feedback": {"pks": ["feedbackId"], "ing": "cdc_with_deletes"},
                "FeedbackFlag": {"pks": ["Feedback_feedbackId", "externalCode"], "ing": "cdc"},
                "PMActivity": {"pks": ["activityId"], "ing": "cdc_with_deletes"},
                "PMAchievement": {"pks": ["achievementId"], "ing": "cdc_with_deletes"},
                "PMActivityFeedback": {"pks": ["activityId", "feedbackId"], "ing": "cdc"},
                "CalibrationSession": {"pks": ["sessionId"], "ing": "cdc"},
                "CalibrationSessionSubject": {"pks": ["sessionSubjectId"], "ing": "cdc"},
                "CalibrationSubjectRank": {"pks": ["subjectRankId"], "ing": "cdc"},
                "CalibrationTemplate": {"pks": ["templateId"], "ing": "cdc"},
            }
            for name, cfg in cpm_entities.items():
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": cfg["pks"], "cursor_field": "lastModifiedDateTime",
                    "ingestion_type": cfg["ing"], "module": "performance",
                    "soft_delete_field": "mdfSystemRecordStatus" if cfg["ing"] == "cdc_with_deletes" else None,
                    "soft_delete_value": "D" if cfg["ing"] == "cdc_with_deletes" else None,
                }

            # ======================================================================
            # Time & Attendance (Mixed protocols)
            # ======================================================================
            time_entities = {
                "TimeAccount": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "TimeAccountDetail": {"pks": ["TimeAccount_externalCode", "externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "TimeAccountPostingRule": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "TimeAccountPurchaseProfile": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "TimeAccountPurchaseProfilePayComponentAssignment": {"pks": ["TimeAccountPurchaseProfile_externalCode", "externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "TimeAccountSnapshot": {"pks": ["accountSnapshotIdentifier"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "TimeAccountType": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "TimeAccountTypeAUS": {"pks": ["TimeAccountType_externalCode", "externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "TimeType": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "TimeTypeProfile": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "EmployeeTimeGroup": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "EmployeeTimeGroupItem": {"pks": ["EmployeeTimeGroup_externalCode", "externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "EmployeeTimeMEX": {"pks": ["EmployeeTime_externalCode", "externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "EmployeeTimeUSA": {"pks": ["EmployeeTime_externalCode", "externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "EmployeeTimeSheet": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "EmployeeTimeSheetEntry": {"pks": ["EmployeeTimeSheet_externalCode", "externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "EmployeeTimeValuationResult": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "WorkSchedule": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "WorkScheduleDay": {"pks": ["WorkSchedule_externalCode", "day"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "WorkScheduleDayModel": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "WorkScheduleDayModelSegment": {"pks": ["WorkScheduleDayModel_externalCode", "externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "HolidayCalendar": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "Holiday": {"pks": ["HolidayCalendar_externalCode", "holidayDate"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "HolidayAssignment": {"pks": ["Holiday_HolidayCalendar_externalCode", "Holiday_holidayDate", "externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "TimeManagementAlert": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "TimeManagementAlertMessage": {"pks": ["TimeManagementAlert_externalCode", "externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "EmployeeTime": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2", "ing": "cdc_with_deletes"},
                "EmployeeTimeAUS": {"pks": ["EmployeeTime_externalCode", "externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "EmployeeTimeCalendar": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "TemporaryTimeInformation": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
                "AvailableTimeType": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime", "api": "odata_v2"},
            }
            for name, cfg in time_entities.items():
                registry[name] = {
                    "api_type": cfg.get("api", "odata_v2"),
                    "path": f"/odata/v2/{name}" if cfg.get("api") == "odata_v2" else f"/odatav4/timemanagement/v1/{name}",
                    "primary_keys": cfg["pks"], "cursor_field": cfg["cursor"],
                    "ingestion_type": cfg.get("ing", "cdc"), "module": "time_attendance",
                    "soft_delete_field": "mdfSystemRecordStatus" if cfg.get("ing") == "cdc_with_deletes" else None,
                    "soft_delete_value": "D" if cfg.get("ing") == "cdc_with_deletes" else None,
                }

            # OData v4 Time entities (ClockInClockOut groups)
            odata_v4_time = ["ClockInClockOutGroup", "ClockInClockOutBreakTimes", "ClockInClockOutConfiguration"]
            for name in odata_v4_time:
                registry[name] = {
                    "api_type": "odata_v4",
                    "path": f"/odatav4/timemanagement/v1/{name}",
                    "primary_keys": ["externalCode"], "cursor_field": "lastModifiedDateTime",
                    "ingestion_type": "cdc", "module": "time_attendance",
                }

            # ======================================================================
            # Succession & Development (OData v2)
            # ======================================================================
            succession_entities = {
                "TalentPool": {"pks": ["code"], "cursor": "lastModifiedDateTime"},
                "Successor": {"pks": ["id"], "cursor": "lastModifiedDateTime"},
                "NominationTarget": {"pks": ["nominationId"], "cursor": "lastModifiedDateTime"},
                "NomineeRelationships": {"pks": ["nomineeId", "nominationId"], "cursor": "lastModifiedDateTime"},
                "RightToReturn": {"pks": ["positionId", "returnToWorkDate", "userId"], "cursor": "lastModifiedDateTime", "ing": "cdc_with_deletes"},
                "PositionCompetencyMappingEntity": {"pks": ["Position_code", "externalCode"], "cursor": "lastModifiedDateTime"},
                "PositionMatrixRelationship": {"pks": ["Position_code", "matrixRelationshipType", "relatedPosition"], "cursor": "lastModifiedDateTime"},
                "PositionRightToReturn": {"pks": ["Position_code", "externalCode"], "cursor": "lastModifiedDateTime"},
                "SuccessionGoal": {"pks": ["goalId"], "cursor": "lastModified"},
                "SuccessionGoalDetail": {"pks": ["goalDetailId"], "cursor": "lastModified"},
                "SuccessionGoalPlan": {"pks": ["goalPlanId"], "cursor": "lastModified"},
                "Mentor": {"pks": ["mentorId"], "cursor": "lastModifiedDateTime"},
                "MentorNominee": {"pks": ["nomineeId"], "cursor": "lastModifiedDateTime"},
                "Competency": {"pks": ["competencyId"], "cursor": "lastModifiedDateTime"},
                "CompetencyContent": {"pks": ["jobProfileId", "roleId"], "cursor": "lastModifiedDateTime"},
                "CompetencyEntity": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "CompetencyRating": {"pks": ["competencyRatingId"], "cursor": "lastModifiedDateTime"},
                "CompetencyType": {"pks": ["GUID"], "cursor": "lastModifiedDateTime"},
                "CertificationContent": {"pks": ["jobProfileId", "roleId"], "cursor": "lastModifiedDateTime"},
                "CertificationEntity": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "LegacyPositionEntity": {"pks": ["positionId"], "cursor": "lastModifiedDateTime"},
                "RoleEntity": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "SkillContent": {"pks": ["jobProfileId", "roleId"], "cursor": "lastModifiedDateTime"},
                "SkillEntity": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "SkillProfile": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "InterviewQuestionContent": {"pks": ["jobProfileId", "roleId"], "cursor": "lastModifiedDateTime"},
                "InterviewQuestionEntity": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "JobProfile": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "JobResponsibilityContent": {"pks": ["jobProfileId", "roleId"], "cursor": "lastModifiedDateTime"},
                "JobResponsibilityEntity": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "EducationDegreeContent": {"pks": ["jobProfileId", "roleId"], "cursor": "lastModifiedDateTime"},
                "EducationDegreeEntity": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "EducationMajorContent": {"pks": ["jobProfileId", "roleId"], "cursor": "lastModifiedDateTime"},
                "EducationMajorEntity": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "PhysicalReqContent": {"pks": ["jobProfileId", "roleId"], "cursor": "lastModifiedDateTime"},
                "PhysicalReqEntity": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "SpotAward": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "SpotAwardBudget": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "SpotAwardCategory": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "SpotAwardGuidelinesRule": {"pks": ["SpotAwardProgram_externalCode", "externalCode"], "cursor": "lastModifiedDateTime"},
                "SpotAwardLevel": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "SpotAwardProgram": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "SpotAwardRedemption": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "SpotAwardRedemptionOrder": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "SpotAwardRedemptionProduct": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
            }
            for name, cfg in succession_entities.items():
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": cfg["pks"], "cursor_field": cfg["cursor"],
                    "ingestion_type": cfg.get("ing", "cdc"), "module": "succession",
                    "soft_delete_field": "mdfSystemRecordStatus" if cfg.get("ing") == "cdc_with_deletes" else None,
                    "soft_delete_value": "D" if cfg.get("ing") == "cdc_with_deletes" else None,
                }

            # ======================================================================
            # Onboarding (OData v2)
            # ======================================================================
            onboarding_entities = {
                "ONB2Process": {"pks": ["processId"], "cursor": "lastModifiedDateTime"},
                "ONB2ProcessTask": {"pks": ["processTaskId"], "cursor": "lastModifiedDateTime"},
                "ONB2ResponsiblePartyConfig": {"pks": ["ONB2ProcessTask_processTaskId", "externalCode"], "cursor": "lastModifiedDateTime"},
                "ONB2ExternalHireData": {"pks": ["externalHireId"], "cursor": "lastModifiedDateTime"},
                "ONB2BuddyActivity": {"pks": ["ONB2Process_processId", "externalCode"], "cursor": "lastModifiedDateTime"},
                "ONB2BuddyProfile": {"pks": ["ONB2Process_processId", "externalCode"], "cursor": "lastModifiedDateTime"},
                "ONB2DataCollectionUserConfig": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "ONB2Equipment": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "ONB2EquipmentActivity": {"pks": ["ONB2Process_processId", "externalCode"], "cursor": "lastModifiedDateTime"},
                "ONB2EquipmentType": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "ONB2EquipmentTypeValue": {"pks": ["ONB2EquipmentType_externalCode", "externalCode"], "cursor": "lastModifiedDateTime"},
                "ONB2NewHireActivitiesStep": {"pks": ["processStepId"], "cursor": "lastModifiedDateTime"},
                "ONB2OffboardeeDetails": {"pks": ["processId"], "cursor": "lastModifiedDateTime"},
                "ONB2OffboardingInfo": {"pks": ["ONB2Process_processId", "externalCode"], "cursor": "lastModifiedDateTime"},
                "ONB2OnboardeeDetails": {"pks": ["processId"], "cursor": "lastModifiedDateTime"},
                "ONB2OnboardingInfo": {"pks": ["ONB2Process_processId", "externalCode"], "cursor": "lastModifiedDateTime"},
                "ONB2RecommendedActivity": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "ONB2ReviewStep": {"pks": ["processStepId"], "cursor": "lastModifiedDateTime"},
                "ONB2WelcomeActivity": {"pks": ["ONB2Process_processId", "externalCode"], "cursor": "lastModifiedDateTime"},
                "ONB2WelcomeStep": {"pks": ["processStepId"], "cursor": "lastModifiedDateTime"},
            }
            for name, cfg in onboarding_entities.items():
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": cfg["pks"], "cursor_field": cfg["cursor"],
                    "ingestion_type": "cdc", "module": "onboarding",
                }

            # ======================================================================
            # Finance & Operations (OData v2)
            # ======================================================================
            finance_entities = {
                # General Ledger Integration
                "GLAccountMapping": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "ExpenseItem": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "ExpenseItemType": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                # Compensation entities
                "LegalEntityDEU": {"pks": ["LegalEntity_externalCode", "externalCode"], "cursor": "lastModifiedDateTime"},
                "LegalEntityESP": {"pks": ["LegalEntity_externalCode", "externalCode"], "cursor": "lastModifiedDateTime"},
                "LegalEntityFRA": {"pks": ["LegalEntity_externalCode", "externalCode"], "cursor": "lastModifiedDateTime"},
                "LegalEntityGBR": {"pks": ["LegalEntity_externalCode", "externalCode"], "cursor": "lastModifiedDateTime"},
                "LegalEntityUSA": {"pks": ["LegalEntity_externalCode", "externalCode"], "cursor": "lastModifiedDateTime"},
                # Payroll entities
                "PayrollConfigurationCategory": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "PayrollExternalHRIS": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "PayrollSystemConfiguration": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "NonRecurringPayment": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
                "RecurringDeduction": {"pks": ["effectiveStartDate", "userSysId"], "cursor": "lastModifiedDateTime"},
                "RecurringDeductionItem": {"pks": ["RecurringDeduction_effectiveStartDate", "RecurringDeduction_userSysId", "payComponentType"], "cursor": "lastModifiedDateTime"},
                "AdvancesInstallments": {"pks": ["NonRecurringPayment_externalCode", "externalCode"], "cursor": "lastModifiedDateTime"},
                # Benefit entities
                "BenefitEnrollmentConfirmation": {"pks": ["benefitEnrollmentId"], "cursor": "lastModifiedDateTime"},
                # Central Compensation
                "CentralCompensation": {"pks": ["effectiveStartDate", "userId"], "cursor": "lastModifiedDateTime"},
                "CentralCompensationItem": {"pks": ["CentralCompensation_effectiveStartDate", "CentralCompensation_userId", "externalCode"], "cursor": "lastModifiedDateTime"},
                "CentralCompensationPayComponent": {"pks": ["CentralCompensationItem_CentralCompensation_effectiveStartDate", "CentralCompensationItem_CentralCompensation_userId", "CentralCompensationItem_externalCode", "payComponent"], "cursor": "lastModifiedDateTime"},
                # Global Benefits
                "BenefitProgramGroupItem": {"pks": ["BenefitProgramGroup_externalCode", "externalCode"], "cursor": "lastModifiedDateTime"},
                "BenefitProgramGroup": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime"},
            }
            for name, cfg in finance_entities.items():
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": cfg["pks"], "cursor_field": cfg["cursor"],
                    "ingestion_type": "cdc", "module": "finance",
                }

            # ======================================================================
            # Learning (OData v2)
            # ======================================================================
            learning_entities = {
                "LearningHistoryData": {"pks": ["lmsId", "userId"], "cursor": "lastModifiedDateTime"},
            }
            for name, cfg in learning_entities.items():
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": cfg["pks"], "cursor_field": cfg["cursor"],
                    "ingestion_type": "cdc", "module": "learning",
                }

            # ======================================================================
            # SCIM 2.0 Identity Entities
            # ======================================================================
            scim_entities = {
                "ScimUser": {"pks": ["id"], "cursor": "lastModified", "path": "/rest/iam/scim/v2/Users"},
                "ScimGroup": {"pks": ["id"], "cursor": "lastModified", "path": "/rest/iam/scim/v2/Groups"},
                "ScimSchema": {"pks": ["id"], "cursor": None, "path": "/rest/iam/scim/v2/Schemas"},
                "ScimResourceType": {"pks": ["id"], "cursor": None, "path": "/rest/iam/scim/v2/ResourceTypes"},
                "ScimServiceProviderConfig": {"pks": ["id"], "cursor": None, "path": "/rest/iam/scim/v2/ServiceProviderConfig"},
            }
            for name, cfg in scim_entities.items():
                registry[name] = {
                    "api_type": "scim_v2", "path": cfg["path"],
                    "primary_keys": cfg["pks"], "cursor_field": cfg["cursor"],
                    "ingestion_type": "cdc" if cfg["cursor"] else "snapshot",
                    "module": "identity",
                }

            # ======================================================================
            # REST API Entities
            # ======================================================================
            rest_entities = {
                # Time Account Balance
                "TimeAccountBalanceResponse": {
                    "pks": ["userId", "timeAccountType"], "cursor": None,
                    "path": "/rest/timemanagement/v1/timeAccountBalance",
                    "method": "POST", "ing": "snapshot"
                },
            }
            for name, cfg in rest_entities.items():
                registry[name] = {
                    "api_type": "rest",
                    "path": cfg["path"],
                    "primary_keys": cfg["pks"],
                    "cursor_field": cfg.get("cursor"),
                    "ingestion_type": cfg.get("ing", "cdc"),
                    "module": "time_attendance",
                    "method": cfg.get("method", "GET"),
                }

            # ======================================================================
            # Additional MDF Entities (Generic objects)
            # ======================================================================
            mdf_entities = [
                "cust_RCMApplicantStatus", "cust_RCMJobReqStatus", "cust_RCMOfferStatus",
                "cust_Location", "cust_Department", "cust_CostCenter",
                "cust_WorkLocation", "cust_PayGrade", "cust_PayRange",
                "cust_EmployeeClass", "cust_EmploymentType", "cust_RegularTemp",
                "cust_ManagerLevel", "cust_JobClassificationMethod",
            ]
            for name in mdf_entities:
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": ["externalCode"], "cursor_field": "lastModifiedDateTime",
                    "ingestion_type": "cdc", "module": "custom",
                }

            # ======================================================================
            # Benefits Management (OData v2) - ~80 entities
            # ======================================================================
            benefit_entities = {
                # Core Benefit entities
                "Benefit": {"pks": ["benefitId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitsProgramDetail": {"pks": ["externalCode", "effectiveStartDate"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitsAvailableProgramOption": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                # Benefit Enrollment
                "BenefitEnrollment": {"pks": ["enrollmentId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitEnrollmentDocument": {"pks": ["documentId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                # Benefit Program
                "BenefitProgram": {"pks": ["programId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitProgramOptions": {"pks": ["optionId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                # Insurance Plans
                "BenefitInsurancePlan": {"pks": ["planId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitInsurancePlanUSA": {"pks": ["BenefitInsurancePlan_planId", "externalCode"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitInsuranceCoverage": {"pks": ["coverageId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitInsuranceCoverageDetails": {"pks": ["detailId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitInsuranceProvider": {"pks": ["providerId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitInsuranceEnrollmentDetails": {"pks": ["detailId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                # Savings Plans
                "BenefitSavingsPlan": {"pks": ["planId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitSavingsPlanSubType": {"pks": ["subTypeId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitSavingsPlanEnrollment": {"pks": ["enrollmentId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                # Pension
                "BenefitPensionFund": {"pks": ["fundId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitPensionPlan": {"pks": ["planId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitPensionPlanContribution": {"pks": ["contributionId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                # Company Car
                "BenefitCompanyCar": {"pks": ["carId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitCompanyCarEnrollment": {"pks": ["enrollmentId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitCompanyCarOrder": {"pks": ["orderId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                # Housing
                "BenefitCompanyHousing": {"pks": ["housingId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitCompanyHousingEnrollment": {"pks": ["enrollmentId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                # Claims
                "BenefitEmployeeClaim": {"pks": ["claimId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitEmployeeClaimDetail": {"pks": ["BenefitEmployeeClaim_claimId", "externalCode"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitClaimConfiguration": {"pks": ["configId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                # Dependents
                "BenefitDependentDetail": {"pks": ["dependentId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitDependentCoverage": {"pks": ["coverageId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                # Events & Configuration
                "BenefitEvent": {"pks": ["eventId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitLifeEventConfiguration": {"pks": ["configId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitDocuments": {"pks": ["documentId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitLegalEntity": {"pks": ["entityId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                # Additional Benefit entities
                "BenefitEligibilityRule": {"pks": ["ruleId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitProgramConfiguration": {"pks": ["configId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitPayComponentDetail": {"pks": ["detailId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitPlanCoverage": {"pks": ["coverageId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitCost": {"pks": ["costId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitsCreditConfiguration": {"pks": ["configId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                # HSA/FSA
                "BenefitHSAEmployerContribution": {"pks": ["contributionId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "BenefitFSAConfiguration": {"pks": ["configId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                # Additional types
                "EmpPensionAdditionalEmployeeContributionDetail": {"pks": ["detailId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "EmpPensionAdditionalEmployerContributionDetail": {"pks": ["detailId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
            }
            for name, cfg in benefit_entities.items():
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": cfg["pks"], "cursor_field": cfg["cursor"],
                    "ingestion_type": cfg.get("ing", "cdc"), "module": "benefits",
                }

            # ======================================================================
            # Compliance Management (OData v2)
            # ======================================================================
            compliance_entities = {
                "ComplianceProcess": {"pks": ["processId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "ComplianceProcessTask": {"pks": ["processTaskId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "ComplianceFormData": {"pks": ["externalCode"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "ComplianceDocumentFlow": {"pks": ["flowId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "ComplianceFormSignature": {"pks": ["signatureId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "ComplianceUserFormData": {"pks": ["userId", "formId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
                "ComplianceFormDataFieldValue": {"pks": ["id"], "cursor": None, "ing": "snapshot"},
                "AssignedComplianceForm": {"pks": ["formId"], "cursor": "lastModifiedDateTime", "ing": "cdc"},
            }
            for name, cfg in compliance_entities.items():
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": cfg["pks"], "cursor_field": cfg["cursor"],
                    "ingestion_type": cfg.get("ing", "cdc"), "module": "onboarding",
                }

            # ======================================================================
            # Onboarding 1.0 Legacy (OData v2)
            # ======================================================================
            onboarding_v1_entities = {
                "OnboardingProcess": {"pks": ["onboardingProcessId"], "cursor": "lastModifiedDateTime"},
                "OnboardingGoal": {"pks": ["goalId"], "cursor": "lastModifiedDateTime"},
                "OnboardingGoalActivity": {"pks": ["activityId"], "cursor": "lastModifiedDateTime"},
                "OnboardingGoalCategory": {"pks": ["categoryId"], "cursor": "lastModifiedDateTime"},
                "OnboardingMeetingActivity": {"pks": ["activityId", "processStepId", "onboardingProcessId"], "cursor": "lastModifiedDateTime"},
                "OnboardingMeetingEvent": {"pks": ["eventId"], "cursor": "lastModifiedDateTime"},
                "OnboardingEquipmentActivity": {"pks": ["activityId", "processStepId", "onboardingProcessId"], "cursor": "lastModifiedDateTime"},
                "OnboardingEquipment": {"pks": ["equipmentId"], "cursor": "lastModifiedDateTime"},
                "OnboardingEquipmentType": {"pks": ["typeId"], "cursor": "lastModifiedDateTime"},
                "OnboardingEquipmentTypeValue": {"pks": ["valueId"], "cursor": "lastModifiedDateTime"},
                "OnboardingCandidateInfo": {"pks": ["applicantId"], "cursor": "lastModifiedDateTime"},
                "OnboardingNewHireActivitiesStep": {"pks": ["processStepId", "onboardingProcessId"], "cursor": "lastModifiedDateTime"},
            }
            for name, cfg in onboarding_v1_entities.items():
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": cfg["pks"], "cursor_field": cfg["cursor"],
                    "ingestion_type": "cdc", "module": "onboarding",
                }

            # ======================================================================
            # Extended REST APIs
            # ======================================================================
            rest_extended = {
                # Custom Tasks (sap-sf-customTasks-v2.json)
                "customTasks": {"pks": ["id"], "path": "/rest/onboarding/v2/customTasks", "ing": "snapshot"},
                # Journey Details (sap-sf-newhirejourney-v1.json)
                "journeyDetails": {"pks": ["journeyId"], "path": "/rest/onboarding/v1/journeyDetails", "ing": "snapshot"},
                # FMLA (sap-sf-FMLARequest-v1.json)
                "FMLARequest": {"pks": ["assignmentId", "id"], "path": "/rest/leave/v1/fmla", "ing": "snapshot"},
                # Employee Compensation (sap-sf-employeeCompensation-v1.json)
                "EmployeeCompEntryDTO": {"pks": ["compEntryId"], "path": "/rest/compensation/v1/entries", "ing": "snapshot"},
                "EmployeeCompSalaryEntryDTO": {"pks": ["entryId"], "path": "/rest/compensation/v1/salary", "ing": "snapshot"},
                "EmployeeCompBonusEntryDTO": {"pks": ["entryId"], "path": "/rest/compensation/v1/bonus", "ing": "snapshot"},
                "EmployeeCompStockEntryDTO": {"pks": ["entryId"], "path": "/rest/compensation/v1/stock", "ing": "snapshot"},
                "EmployeeCompVarpayEntryDTO": {"pks": ["entryId"], "path": "/rest/compensation/v1/varpay", "ing": "snapshot"},
                "EmployeeCompForceCommentDTO": {"pks": ["commentId"], "path": "/rest/compensation/v1/comments", "ing": "cdc"},
                # Position Budgeting Control (sap-sf-PositionBudgetingControl-v1.json)
                "PBCReplicationData": {"pks": ["id", "startDate", "endDate"], "path": "/rest/pbc/v1/replication", "ing": "cdc"},
                "SymbolicAccountData": {"pks": ["id"], "path": "/rest/pbc/v1/symbolicAccounts", "ing": "cdc"},
                "EmployeeGroupingData": {"pks": ["id"], "path": "/rest/pbc/v1/employeeGrouping", "ing": "cdc"},
                # I-9 Audit Trail (i9audittrail.json)
                "i9AuditTrailRecord": {"pks": ["externalCode"], "path": "/rest/iam/i9/v1/audittrail", "ing": "append"},
                # Time APIs
                "TimeTypeBalanceResponse": {"pks": ["userId", "timeTypeCode"], "path": "/rest/timemanagement/v1/timeTypeBalance", "ing": "snapshot"},
                "TerminationTimeAccountBalanceResponse": {"pks": ["userId"], "path": "/rest/timemanagement/v1/terminationBalance", "ing": "snapshot"},
                "TimeOffEventResponse": {"pks": ["externalCode"], "path": "/rest/timemanagement/absence/v1/events", "ing": "snapshot"},
                "AvailableTimeType": {"pks": ["externalCode"], "path": "/rest/timemanagement/v1/availableTimeTypes", "ing": "snapshot"},
                # DPCS (Data Privacy Consent)
                "DPCSVersion": {"pks": ["id"], "path": "/rest/dpcs/v1/version", "ing": "snapshot"},
                "DPCSStatus": {"pks": ["type", "country", "subjectId"], "path": "/rest/dpcs/v1/status", "ing": "snapshot"},
                # Extension Point
                "ExtensionPointTaskDetail": {"pks": ["taskId"], "path": "/rest/extension/v1/tasks", "ing": "snapshot"},
                # Instructional Text
                "InstructionalTextEO": {"pks": ["id"], "path": "/rest/instructional/v1/text", "ing": "snapshot"},
            }
            for name, cfg in rest_extended.items():
                registry[name] = {
                    "api_type": "rest", "path": cfg["path"],
                    "primary_keys": cfg["pks"], "cursor_field": None,
                    "ingestion_type": cfg.get("ing", "snapshot"), "module": "rest_api",
                    "method": cfg.get("method", "GET"),
                }

            # ======================================================================
            # Additional Payment Country Variants
            # ======================================================================
            additional_payment_countries = [
                "ARG", "AUT", "BEL", "BLR", "BOL", "CHE", "CHL", "COL",
                "CZE", "DNK", "EGY", "ESP", "FIN", "GRC", "HKG", "HUN",
                "IDN", "IRL", "ISR", "ITA", "KOR", "MYS", "NLD", "NOR",
                "NZL", "PHL", "POL", "PRT", "RUS", "SAU", "SGP", "SVK",
                "SVN", "SWE", "THA", "TUN", "TUR", "TWN", "VEN", "ZAF"
            ]
            for country in additional_payment_countries:
                name = f"PaymentInformationDetailV3{country}"
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": ["PaymentInformationDetailV3_PaymentInformationV3_effectiveStartDate",
                                     "PaymentInformationDetailV3_PaymentInformationV3_worker",
                                     "PaymentInformationDetailV3_externalCode", "externalCode"],
                    "cursor_field": "lastModifiedDateTime", "ingestion_type": "cdc",
                    "module": "employee_central",
                }

            # Additional Legal Entity Country Variants
            additional_legal_countries = [
                "ARG", "AUS", "AUT", "BEL", "BLR", "BOL", "BRA", "CAN", "CHE", "CHL",
                "CHN", "COL", "CZE", "DNK", "EGY", "FIN", "GRC", "HKG", "HUN", "IDN",
                "IND", "IRL", "ISR", "ITA", "JPN", "KOR", "MEX", "MYS", "NLD", "NOR",
                "NZL", "PHL", "POL", "PRT", "RUS", "SAU", "SGP", "SVK", "SVN", "SWE",
                "THA", "TUN", "TUR", "TWN", "VEN", "ZAF"
            ]
            for country in additional_legal_countries:
                name = f"LegalEntity{country}"
                if name not in registry:  # Don't overwrite existing ones
                    registry[name] = {
                        "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                        "primary_keys": ["LegalEntity_externalCode", "externalCode"],
                        "cursor_field": "lastModifiedDateTime", "ingestion_type": "cdc",
                        "module": "finance",
                    }

            # ======================================================================
            # Advanced Goal & Form Entities
            # ======================================================================
            # Goal Permission variants (snapshot - configuration data)
            for i in range(1, 9):
                registry[f"GoalPermission_{i}"] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/GoalPermission_{i}",
                    "primary_keys": ["id"], "cursor_field": None,
                    "ingestion_type": "snapshot", "module": "performance",
                }
                # Goal Milestone variants
                registry[f"GoalMilestone_{i}"] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/GoalMilestone_{i}",
                    "primary_keys": ["id"], "cursor_field": "lastModified",
                    "ingestion_type": "cdc", "module": "performance",
                }
                # Goal Comment variants
                registry[f"GoalComment_{i}"] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/GoalComment_{i}",
                    "primary_keys": ["id"], "cursor_field": "lastModified",
                    "ingestion_type": "cdc", "module": "performance",
                }
                # Goal Task Permission variants
                registry[f"GoalTaskPermission_{i}"] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/GoalTaskPermission_{i}",
                    "primary_keys": ["id"], "cursor_field": None,
                    "ingestion_type": "snapshot", "module": "performance",
                }
                # Goal Milestone Permission variants
                registry[f"GoalMilestonePermission_{i}"] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/GoalMilestonePermission_{i}",
                    "primary_keys": ["id"], "cursor_field": None,
                    "ingestion_type": "snapshot", "module": "performance",
                }

            # Team Goals (specific plan types)
            for i in [1, 5, 7]:
                registry[f"TeamGoal_{i}"] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/TeamGoal_{i}",
                    "primary_keys": ["id"], "cursor_field": "lastModified",
                    "ingestion_type": "cdc", "module": "performance",
                }

            # Goal_101 (custom plan type)
            registry["Goal_101"] = {
                "api_type": "odata_v2", "path": "/odata/v2/Goal_101",
                "primary_keys": ["id"], "cursor_field": "lastModified",
                "ingestion_type": "cdc_with_deletes", "module": "performance",
                "soft_delete_field": "state", "soft_delete_value": "deleted",
            }

            # DevGoal variants
            for i in [2001, 2002]:
                registry[f"DevGoal_{i}"] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/DevGoal_{i}",
                    "primary_keys": ["id"], "cursor_field": "lastModified",
                    "ingestion_type": "cdc", "module": "performance",
                }
                registry[f"DevGoalPermission_{i}"] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/DevGoalPermission_{i}",
                    "primary_keys": ["id"], "cursor_field": None,
                    "ingestion_type": "snapshot", "module": "performance",
                }

            # Form360 entities
            form360_entities = {
                "Form360Participant": {"pks": ["formContentId", "formDataId", "participantId"], "cursor": "lastModifiedDateTime"},
                "Form360ParticipantConfig": {"pks": ["configId"], "cursor": "lastModifiedDateTime"},
                "Form360ParticipantSection": {"pks": ["formContentId", "formDataId", "participantId", "sectionIndex"], "cursor": "lastModifiedDateTime"},
                "Form360ParticipantDetail": {"pks": ["formContentId", "formDataId", "participantId", "itemId", "sectionIndex"], "cursor": "lastModifiedDateTime"},
                "Form360ParticipantCategory": {"pks": ["formContentId", "formDataId", "categoryOrder"], "cursor": "lastModifiedDateTime"},
                "Form360ParticipantColumn": {"pks": ["formContentId", "formDataId", "columnKey"], "cursor": "lastModifiedDateTime"},
                "Form360Rater": {"pks": ["formContentId", "formDataId", "participantId"], "cursor": "lastModifiedDateTime"},
                "Form360RaterSection": {"pks": ["formContentId", "formDataId", "participantId", "sectionIndex"], "cursor": "lastModifiedDateTime"},
                "Form360SummarySection": {"pks": ["formContentId", "formDataId", "sectionIndex"], "cursor": "lastModifiedDateTime"},
                "Form360ReviewContentDetail": {"pks": ["formContentId", "formDataId"], "cursor": "lastModifiedDateTime"},
            }
            for name, cfg in form360_entities.items():
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": cfg["pks"], "cursor_field": cfg["cursor"],
                    "ingestion_type": "cdc", "module": "performance",
                }

            # ======================================================================
            # Dynamic Groups Extended
            # ======================================================================
            dg_extended = {
                "DynamicGroupDefinition": {"pks": ["groupId"], "cursor": "lastModifiedDateTime"},
                "DGExpression": {"pks": ["expressionId"], "cursor": "lastModifiedDateTime"},
                "DGField": {"pks": ["fieldId"], "cursor": "lastModifiedDateTime"},
                "DGFieldValue": {"pks": ["fieldId", "valueId"], "cursor": "lastModifiedDateTime"},
                "DGFilter": {"pks": ["filterId"], "cursor": "lastModifiedDateTime"},
                "DGPeoplePool": {"pks": ["poolId"], "cursor": "lastModifiedDateTime"},
                "DGFieldOperator": {"pks": ["operatorId"], "cursor": "lastModifiedDateTime"},
            }
            for name, cfg in dg_extended.items():
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": cfg["pks"], "cursor_field": cfg["cursor"],
                    "ingestion_type": "cdc", "module": "platform",
                }

            # ======================================================================
            # Finance GO Entities (cdc_with_deletes)
            # ======================================================================
            finance_go = {
                "BudgetPeriodGO": {"pks": ["budgetPeriodId", "effectiveStartDate"]},
                "FunctionalAreaGO": {"pks": ["functionalAreaID", "effectiveStartDate"]},
                "FundCenterGO": {"pks": ["externalCode", "effectiveStartDate"]},
                "FundGO": {"pks": ["externalCode", "effectiveStartDate"]},
                "GrantGO": {"pks": ["grantCode", "effectiveStartDate"]},
                "ProjectControllingObject": {"pks": ["externalCode", "effectiveStartDate"]},
            }
            for name, cfg in finance_go.items():
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": cfg["pks"], "cursor_field": "lastModifiedDateTime",
                    "ingestion_type": "cdc_with_deletes", "module": "finance",
                    "soft_delete_field": "mdfSystemRecordStatus", "soft_delete_value": "D",
                }

            # ======================================================================
            # OData v4 Extended Entities
            # ======================================================================
            odata_v4_extended = {
                "AdditionalServices": {"pks": ["id"], "cursor": None, "path": "/odatav4/onboarding/AdditionalServices.svc/v1", "ing": "snapshot"},
                "CalibrationSessionV4": {"pks": ["sessionId"], "cursor": "lastModifiedDateTime", "path": "/odatav4/calibration/v1/CalibrationSession", "ing": "cdc"},
                "CalibrationSubjectV4": {"pks": ["subjectId"], "cursor": "lastModifiedDateTime", "path": "/odatav4/calibration/v1/CalibrationSubject", "ing": "cdc"},
                "CalibrationSubjectComment": {"pks": ["commentId"], "cursor": "lastModifiedDateTime", "path": "/odatav4/calibration/v1/CalibrationSubjectComment", "ing": "cdc"},
                "ClockInClockOutExternal": {"pks": ["externalId"], "cursor": "lastChangedAt", "path": "/odatav4/timemanagement/ClockInClockOutExternal/v1", "ing": "cdc"},
                "timeevents": {"pks": ["externalId"], "cursor": "lastChangedAt", "path": "/odatav4/timemanagement/ClockInClockOutTimeEventsRestAPI/v1/timeevents", "ing": "append"},
                "TimeEventTypes": {"pks": ["code"], "cursor": None, "path": "/odatav4/timemanagement/v1/TimeEventTypes", "ing": "snapshot"},
                "SCMNominationApprovalWorkflow": {"pks": ["approvalId"], "cursor": "lastModifiedDateTime", "path": "/odatav4/scm/v1/NominationApprovalWorkflow", "ing": "cdc"},
            }
            for name, cfg in odata_v4_extended.items():
                registry[name] = {
                    "api_type": "odata_v4", "path": cfg["path"],
                    "primary_keys": cfg["pks"], "cursor_field": cfg["cursor"],
                    "ingestion_type": cfg.get("ing", "cdc"), "module": "odata_v4",
                }

            # ======================================================================
            # Platform Extended Entities
            # ======================================================================
            platform_extended = {
                # External User/Learner entities
                "ExternalUser": {"pks": ["externalUserId"], "cursor": "lastModifiedDateTime"},
                "ExternalLearner": {"pks": ["externalLearnerId"], "cursor": "lastModifiedDateTime"},
                "ExternalLearnerPersonalInfo": {"pks": ["ExternalLearner_externalLearnerId", "itemId"], "cursor": "lastModifiedDateTime"},
                "ExternalLearnerEmailInfo": {"pks": ["ExternalLearner_externalLearnerId", "itemId"], "cursor": "lastModifiedDateTime"},
                "ExternalLearnerAddressInfo": {"pks": ["ExternalLearner_externalLearnerId", "itemId"], "cursor": "lastModifiedDateTime"},
                "ExternalLearnerPhoneInfo": {"pks": ["ExternalLearner_externalLearnerId", "itemId"], "cursor": "lastModifiedDateTime"},
                # Extended Personal Info
                "ExtAddressInfo": {"pks": ["addressId"], "cursor": "lastModifiedDateTime"},
                "ExtEmailInfo": {"pks": ["emailId"], "cursor": "lastModifiedDateTime"},
                "ExtPersonalInfo": {"pks": ["personalInfoId"], "cursor": "lastModifiedDateTime"},
                "ExtPhoneInfo": {"pks": ["phoneId"], "cursor": "lastModifiedDateTime"},
                # Execution Manager
                "EMMonitoredProcess": {"pks": ["processDefinitionId", "processInstanceId", "processType"], "cursor": "lastEventTime", "ing": "cdc"},
                "EMEvent": {"pks": ["id"], "cursor": "eventTime", "ing": "append"},
                "EMEventPayload": {"pks": ["eventId", "payloadId"], "cursor": "eventTime", "ing": "append"},
                "EMEventAttribute": {"pks": ["eventId", "attributeId"], "cursor": "eventTime", "ing": "append"},
                # Theme entities
                "ThemeTemplate": {"pks": ["id"], "cursor": "lastModifiedDate", "ing": "cdc"},
                "ThemeExternalResource": {"pks": ["themeId", "resourceId"], "cursor": "lastModifiedDate", "ing": "cdc"},
                # Permission entities
                "RBPBasicPermission": {"pks": ["permissionId"], "cursor": "lastModifiedDateTime"},
                "RBPRole": {"pks": ["roleId"], "cursor": "lastModifiedDateTime"},
                "RBPRule": {"pks": ["ruleId"], "cursor": "lastModifiedDateTime"},
                "UserPermissions": {"pks": ["userId"], "cursor": "lastModifiedDateTime"},
                "UserCapabilities": {"pks": ["userId"], "cursor": "lastModifiedDateTime"},
                # Workflow extended
                "WfRequestParticipator": {"pks": ["wfRequestParticipatorId"], "cursor": "lastModifiedOn"},
                # Currency
                "CurrencyConversion": {"pks": ["fromCurrency", "toCurrency", "effectiveDate"], "cursor": "lastModifiedDateTime"},
                # MDF entities
                "MDFEnumValue": {"pks": ["externalCode", "mdfSystemEffectiveStartDate"], "cursor": "lastModifiedDateTime"},
                "MDFLocalizedValue": {"pks": ["externalCode", "locale"], "cursor": "lastModifiedDateTime"},
                # Work Order
                "WorkOrder": {"pks": ["workOrderId"], "cursor": "lastModifiedDateTime"},
                "VendorInfo": {"pks": ["vendorId"], "cursor": "lastModifiedDateTime"},
                # Initiative
                "InitiativeAlignmentBean": {"pks": ["initiativeId"], "cursor": "lastModifiedDateTime"},
                # Company Provisioner
                "CompanyProvisioner": {"pks": ["id"], "cursor": "lastModifiedDateTime"},
                # Success Store
                "SuccessStoreContentBlob": {"pks": ["contentId", "blobId"], "cursor": None, "ing": "snapshot"},
            }
            for name, cfg in platform_extended.items():
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": cfg["pks"], "cursor_field": cfg["cursor"],
                    "ingestion_type": cfg.get("ing", "cdc"), "module": "platform",
                }

            # ======================================================================
            # Recruiting Extended Entities
            # ======================================================================
            recruiting_extended = {
                "JobApplicationAssessmentOrder": {"pks": ["assessmentOrderId"], "cursor": "lastModifiedDateTime"},
                "JobApplicationAssessmentReport": {"pks": ["reportId"], "cursor": "lastModifiedDateTime"},
                "JobApplicationAssessmentReportDetail": {"pks": ["reportId", "detailId"], "cursor": "lastModifiedDateTime"},
                "JobApplicationBackgroundCheckRequest": {"pks": ["requestId"], "cursor": "lastModifiedDateTime"},
                "JobApplicationBackgroundCheckResult": {"pks": ["resultId"], "cursor": "lastModifiedDateTime"},
                "JobApplicationQuestionResponse": {"pks": ["responseId"], "cursor": "lastModifiedDateTime"},
                "JobApplicationStatus": {"pks": ["statusId"], "cursor": "lastModifiedDateTime"},
                "JobApplicationStatusLabel": {"pks": ["labelId"], "cursor": "lastModifiedDateTime"},
                "JobReqQuestion": {"pks": ["questionId"], "cursor": "lastModifiedDateTime"},
                "JobReqScreeningQuestion": {"pks": ["questionId"], "cursor": "lastModifiedDateTime"},
                "JobReqScreeningQuestionChoice": {"pks": ["questionId", "choiceId"], "cursor": "lastModifiedDateTime"},
                "JobReqGOPosition": {"pks": ["jobReqId", "positionId"], "cursor": "lastModifiedDateTime"},
                "JobRequisitionGroupOperator": {"pks": ["jobReqId", "operatorRole", "recruiterId"], "cursor": "lastModifiedDateTime"},
                "JobReqFwdCandidates": {"pks": ["candidateId", "jobReqId"], "cursor": "lastModifiedDateTime"},
                "InterviewIndividualAssessment": {"pks": ["assessmentId"], "cursor": "lastModifiedDateTime"},
            }
            for name, cfg in recruiting_extended.items():
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": cfg["pks"], "cursor_field": cfg["cursor"],
                    "ingestion_type": "cdc", "module": "recruiting",
                }

            # ======================================================================
            # Succession Extended Entities
            # ======================================================================
            succession_extended = {
                "NomineeHistory": {"pks": ["historyId"], "cursor": "lastModifiedDateTime"},
                "TalentGraphicOption": {"pks": ["optionId"], "cursor": "lastModifiedDateTime"},
                "TalentRatings": {"pks": ["ratingId"], "cursor": "lastModifiedDateTime"},
                "CalibrationSessionOwner": {"pks": ["sessionId", "ownerId"], "cursor": "lastModifiedDateTime"},
                "CalibrationSessionReviewer": {"pks": ["sessionId", "reviewerId"], "cursor": "lastModifiedDateTime"},
                "CalibrationExecutiveReviewer": {"pks": ["sessionId", "reviewerId"], "cursor": "lastModifiedDateTime"},
                "CalibrationSubjectRating": {"pks": ["ratingId"], "cursor": "lastModifiedDateTime"},
                "CalibrationRating": {"pks": ["ratingId"], "cursor": "lastModifiedDateTime"},
                "CalibrationRatingOption": {"pks": ["optionId"], "cursor": "lastModifiedDateTime"},
                "CalibrationTemplateRater": {"pks": ["templateId", "raterId"], "cursor": "lastModifiedDateTime"},
                "CalibrationTemplateCommentType": {"pks": ["templateId", "typeId"], "cursor": "lastModifiedDateTime"},
                "CalibrationTemplateCommentFieldName": {"pks": ["templateId", "fieldNameId"], "cursor": "lastModifiedDateTime"},
                "CalibrationSubjectWeightage": {"pks": ["subjectId", "weightageId"], "cursor": "lastModifiedDateTime"},
                "CalibrationSubjectObjectRanking": {"pks": ["subjectId", "rankingId"], "cursor": "lastModifiedDateTime"},
                "CalibrationCompetencyRating": {"pks": ["ratingId"], "cursor": "lastModifiedDateTime"},
                "DevLearning_4201": {"pks": ["learningId"], "cursor": None, "ing": "snapshot"},
                "DevLearningCertifications": {"pks": ["certificationId"], "cursor": "lastModifiedDateTime"},
            }
            for name, cfg in succession_extended.items():
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": cfg["pks"], "cursor_field": cfg["cursor"],
                    "ingestion_type": cfg.get("ing", "cdc"), "module": "succession",
                }

            # ======================================================================
            # Time Extended Entities
            # ======================================================================
            time_extended = {
                "TimeEventType": {"pks": ["code"], "cursor": "lastModifiedDateTime"},
                "ClockInClockOutMessage": {"pks": ["messageId"], "cursor": "lastModifiedDateTime"},
            }
            for name, cfg in time_extended.items():
                registry[name] = {
                    "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                    "primary_keys": cfg["pks"], "cursor_field": cfg["cursor"],
                    "ingestion_type": "cdc", "module": "time_attendance",
                }

            # ======================================================================
            # Job Classification Country Variants
            # ======================================================================
            job_classification_countries = ["AUS", "BRA", "CAN", "FRA", "GBR", "ITA", "USA", "ZAF"]
            for country in job_classification_countries:
                name = f"JobClassificationCountry{country}"
                if name not in registry:
                    registry[name] = {
                        "api_type": "odata_v2", "path": f"/odata/v2/{name}",
                        "primary_keys": ["JobClassificationCountry_externalCode", "externalCode"],
                        "cursor_field": "lastModifiedDateTime", "ingestion_type": "cdc",
                        "module": "employee_central",
                    }

            return registry

        # Initialize registry at class level
        _ENTITY_REGISTRY = _build_entity_registry.__func__(None)

        # ==========================================================================
        # Static Schema Definitions (for key entities)
        # Other entities use dynamic schema generation
        # ==========================================================================

        _SCHEMAS: Dict[str, StructType] = {
            "User": StructType([
                StructField("userId", StringType(), False),
                StructField("username", StringType(), True),
                StructField("firstName", StringType(), True),
                StructField("lastName", StringType(), True),
                StructField("middleName", StringType(), True),
                StructField("email", StringType(), True),
                StructField("defaultLocale", StringType(), True),
                StructField("status", StringType(), True),
                StructField("timeZone", StringType(), True),
                StructField("hireDate", StringType(), True),
                StructField("lastModifiedDateTime", StringType(), True),
                StructField("createdDateTime", StringType(), True),
                StructField("lastModifiedBy", StringType(), True),
                StructField("createdBy", StringType(), True),
                StructField("empId", StringType(), True),
                StructField("department", StringType(), True),
                StructField("division", StringType(), True),
                StructField("jobCode", StringType(), True),
                StructField("location", StringType(), True),
                StructField("managerId", StringType(), True),
                StructField("hr", StringType(), True),
                StructField("title", StringType(), True),
                StructField("businessPhone", StringType(), True),
                StructField("fax", StringType(), True),
                StructField("addressLine1", StringType(), True),
                StructField("addressLine2", StringType(), True),
                StructField("city", StringType(), True),
                StructField("state", StringType(), True),
                StructField("zipCode", StringType(), True),
                StructField("country", StringType(), True),
            ]),

            "EmpEmployment": StructType([
                StructField("personIdExternal", StringType(), False),
                StructField("userId", StringType(), False),
                StructField("startDate", StringType(), True),
                StructField("endDate", StringType(), True),
                StructField("firstDateWorked", StringType(), True),
                StructField("lastDateWorked", StringType(), True),
                StructField("originalStartDate", StringType(), True),
                StructField("seniorityDate", StringType(), True),
                StructField("serviceDate", StringType(), True),
                StructField("assignmentClass", StringType(), True),
                StructField("isContingentWorker", BooleanType(), True),
                StructField("isECRecord", BooleanType(), True),
                StructField("jobNumber", LongType(), True),
                StructField("okToRehire", BooleanType(), True),
                StructField("regretTermination", BooleanType(), True),
                StructField("eligibleForStock", BooleanType(), True),
                StructField("eligibleForSalContinuation", BooleanType(), True),
                StructField("employeeFirstEmployment", BooleanType(), True),
                StructField("prevEmployeeId", StringType(), True),
                StructField("createdBy", StringType(), True),
                StructField("createdDateTime", StringType(), True),
                StructField("lastModifiedBy", StringType(), True),
                StructField("lastModifiedDateTime", StringType(), True),
            ]),

            "EmpJob": StructType([
                StructField("seqNumber", LongType(), False),
                StructField("startDate", StringType(), False),
                StructField("userId", StringType(), False),
                StructField("endDate", StringType(), True),
                StructField("company", StringType(), True),
                StructField("businessUnit", StringType(), True),
                StructField("department", StringType(), True),
                StructField("division", StringType(), True),
                StructField("costCenter", StringType(), True),
                StructField("location", StringType(), True),
                StructField("position", StringType(), True),
                StructField("jobCode", StringType(), True),
                StructField("jobTitle", StringType(), True),
                StructField("payGrade", StringType(), True),
                StructField("managerId", StringType(), True),
                StructField("emplStatus", StringType(), True),
                StructField("employeeClass", StringType(), True),
                StructField("employmentType", StringType(), True),
                StructField("regularTemp", StringType(), True),
                StructField("contractType", StringType(), True),
                StructField("fte", DoubleType(), True),
                StructField("standardHours", DoubleType(), True),
                StructField("workingDaysPerWeek", DoubleType(), True),
                StructField("isFulltimeEmployee", BooleanType(), True),
                StructField("event", StringType(), True),
                StructField("eventReason", StringType(), True),
                StructField("timezone", StringType(), True),
                StructField("workscheduleCode", StringType(), True),
                StructField("countryOfCompany", StringType(), True),
                StructField("createdBy", StringType(), True),
                StructField("createdDateTime", StringType(), True),
                StructField("lastModifiedBy", StringType(), True),
                StructField("lastModifiedDateTime", StringType(), True),
            ]),

            "PerPerson": StructType([
                StructField("personIdExternal", StringType(), False),
                StructField("personId", LongType(), True),
                StructField("userId", StringType(), True),
                StructField("perPersonUuid", StringType(), True),
                StructField("dateOfBirth", StringType(), True),
                StructField("countryOfBirth", StringType(), True),
                StructField("placeOfBirth", StringType(), True),
                StructField("createdBy", StringType(), True),
                StructField("createdDateTime", StringType(), True),
                StructField("lastModifiedBy", StringType(), True),
                StructField("lastModifiedDateTime", StringType(), True),
            ]),

            "PerPersonal": StructType([
                StructField("personIdExternal", StringType(), False),
                StructField("startDate", StringType(), False),
                StructField("endDate", StringType(), True),
                StructField("firstName", StringType(), True),
                StructField("lastName", StringType(), True),
                StructField("middleName", StringType(), True),
                StructField("gender", StringType(), True),
                StructField("maritalStatus", StringType(), True),
                StructField("nationality", StringType(), True),
                StructField("displayName", StringType(), True),
                StructField("preferredName", StringType(), True),
                StructField("title", StringType(), True),
                StructField("suffix", StringType(), True),
                StructField("salutation", StringType(), True),
                StructField("createdBy", StringType(), True),
                StructField("createdDateTime", StringType(), True),
                StructField("lastModifiedBy", StringType(), True),
                StructField("lastModifiedDateTime", StringType(), True),
            ]),

            "EmpCostAssignment": StructType([
                StructField("effectiveStartDate", StringType(), False),
                StructField("worker", StringType(), False),
                StructField("effectiveEndDate", StringType(), True),
                StructField("companyCode", StringType(), True),
                StructField("mdfSystemRecordStatus", StringType(), True),
                StructField("mdfSystemStatus", StringType(), True),
                StructField("doNotSyncFromPositionCostAssignment", BooleanType(), True),
                StructField("skipValidationDerivation", BooleanType(), True),
                StructField("createdBy", StringType(), True),
                StructField("createdDateTime", StringType(), True),
                StructField("lastModifiedBy", StringType(), True),
                StructField("lastModifiedDateTime", StringType(), True),
            ]),
        }

        # FO Objects share common schema pattern
        _FO_SCHEMA = StructType([
            StructField("externalCode", StringType(), False),
            StructField("startDate", StringType(), False),
            StructField("endDate", StringType(), True),
            StructField("name", StringType(), True),
            StructField("name_localized", StringType(), True),
            StructField("description", StringType(), True),
            StructField("description_localized", StringType(), True),
            StructField("status", StringType(), True),
            StructField("createdBy", StringType(), True),
            StructField("createdDateTime", StringType(), True),
            StructField("lastModifiedBy", StringType(), True),
            StructField("lastModifiedDateTime", StringType(), True),
        ])

        # Add FO schemas
        for _fo_name in ["FODepartment", "FOCompany", "FOCostCenter", "FOJobCode",
                         "FOLocation", "FOBusinessUnit", "FODivision", "FOPayGrade"]:
            _SCHEMAS[_fo_name] = _FO_SCHEMA

        # ==========================================================================
        # Module-based organization for documentation
        # ==========================================================================

        @classmethod
        def _build_module_tables(cls) -> Dict[str, List[str]]:
            """Build module-to-tables mapping from registry."""
            modules: Dict[str, List[str]] = {}
            registry = cls._ENTITY_REGISTRY if cls else LakeflowConnect._ENTITY_REGISTRY
            for name, cfg in registry.items():
                module = cfg.get("module", "other")
                if module not in modules:
                    modules[module] = []
                modules[module].append(name)
            return modules

        # Build module tables after class definition (populated below)
        _MODULE_TABLES: Dict[str, List[str]] = {}

        # ==========================================================================
        # Constants
        # ==========================================================================

        DEFAULT_PAGE_SIZE = 1000
        MAX_RETRIES = 3
        RETRY_DELAY_SECONDS = 1.0

        # ==========================================================================
        # Initialization
        # ==========================================================================

        def __init__(self, options: dict[str, str]) -> None:
            """
            Initialize the SAP SuccessFactors connector.

            Args:
                options: Connection parameters:
                    - api_server (required): SAP SuccessFactors API server
                    - company_id (required): Company identifier
                    - user_id (required): API user ID
                    - password (required): Password or API key
                    - auth_type (optional): "basic" (default) or "oauth"
                    - page_size (optional): Records per page (default: 1000)
            """
            # Required parameters
            self.api_server = options.get("api_server")
            self.company_id = options.get("company_id")
            self.user_id = options.get("user_id")
            self.password = options.get("password")

            if not all([self.api_server, self.company_id, self.user_id, self.password]):
                raise ValueError(
                    "Missing required connection parameters. "
                    "Required: api_server, company_id, user_id, password"
                )

            # Optional parameters
            self.auth_type = options.get("auth_type", "basic")
            self.page_size = int(options.get("page_size", self.DEFAULT_PAGE_SIZE))

            # Construct base URL
            self.base_url = f"https://{self.api_server}"

            # Setup authentication headers
            self._setup_auth_headers()

            # HTTP session for connection pooling
            self._session = requests.Session()
            self._session.headers.update(self.auth_headers)

            # Schema cache
            self._schema_cache: Dict[str, StructType] = {}

        def _setup_auth_headers(self) -> None:
            """Setup authentication headers based on auth_type."""
            if self.auth_type == "basic":
                credentials = f"{self.user_id}@{self.company_id}:{self.password}"
                encoded = base64.b64encode(credentials.encode()).decode()
                self.auth_headers = {
                    "Authorization": f"Basic {encoded}",
                    "Content-Type": "application/json",
                    "Accept": "application/json",
                }
            else:
                raise ValueError(f"Unsupported auth_type: {self.auth_type}. Only 'basic' is supported.")

        # ==========================================================================
        # LakeflowConnect Interface Methods
        # ==========================================================================

        def list_tables(self) -> List[str]:
            """List names of all tables supported by the connector."""
            return list(self._ENTITY_REGISTRY.keys())

        def get_table_schema(
            self, table_name: str, table_options: Dict[str, str]
        ) -> StructType:
            """
            Get the Spark schema for a table.

            Uses static schemas for key entities, dynamic generation for others.
            """
            self._validate_table_name(table_name)

            # Check cache first
            if table_name in self._schema_cache:
                return self._schema_cache[table_name]

            # Check static definitions
            if table_name in self._SCHEMAS:
                schema = self._SCHEMAS[table_name]
                self._schema_cache[table_name] = schema
                return schema

            # Generate dynamic schema
            schema = self._generate_dynamic_schema(table_name, table_options)
            self._schema_cache[table_name] = schema
            return schema

        def _generate_dynamic_schema(
            self, table_name: str, table_options: Dict[str, str]
        ) -> StructType:
            """
            Generate schema dynamically by fetching sample data from API.

            Falls back to a generic schema if API call fails.
            """
            entity_config = self._ENTITY_REGISTRY[table_name]

            # Try to fetch schema from API metadata or sample data
            try:
                api_type = entity_config["api_type"]
                path = entity_config["path"]

                if api_type == "odata_v2":
                    # Fetch $metadata or a single record
                    url = f"{self.base_url}{path}"
                    params = {"$format": "json", "$top": "1"}
                    response = self._make_request_with_retry("GET", url, params=params)
                    data = response.json()
                    records = data.get("d", {}).get("results", [])

                    if records:
                        return self._infer_schema_from_record(records[0], entity_config)

                elif api_type == "scim_v2":
                    # SCIM schema inference
                    url = f"{self.base_url}{path}"
                    params = {"count": "1"}
                    response = self._make_request_with_retry("GET", url, params=params)
                    data = response.json()
                    resources = data.get("Resources", [])

                    if resources:
                        return self._infer_schema_from_record(resources[0], entity_config)

            except Exception as e:
                logger.warning(f"Could not fetch schema for {table_name}: {e}. Using generic schema.")

            # Fallback: generic schema based on entity config
            return self._create_generic_schema(entity_config)

        def _infer_schema_from_record(
            self, record: dict, entity_config: Dict[str, Any]
        ) -> StructType:
            """Infer Spark schema from a sample record."""
            fields = []
            primary_keys = set(entity_config.get("primary_keys", []))

            for key, value in record.items():
                if key.startswith("__"):
                    continue  # Skip OData metadata

                nullable = key not in primary_keys
                spark_type = self._infer_spark_type(value)
                fields.append(StructField(key, spark_type, nullable))

            # Ensure primary keys are present
            existing_fields = {f.name for f in fields}
            for pk in primary_keys:
                if pk not in existing_fields:
                    fields.insert(0, StructField(pk, StringType(), False))

            return StructType(fields)

        def _infer_spark_type(self, value: Any) -> Any:
            """Infer Spark data type from Python value."""
            if value is None:
                return StringType()
            elif isinstance(value, bool):
                return BooleanType()
            elif isinstance(value, int):
                return LongType()
            elif isinstance(value, float):
                return DoubleType()
            elif isinstance(value, list):
                if value:
                    element_type = self._infer_spark_type(value[0])
                else:
                    element_type = StringType()
                return ArrayType(element_type)
            elif isinstance(value, dict):
                if "__deferred" in value:
                    return StringType()  # Navigation property placeholder
                nested_fields = []
                for k, v in value.items():
                    if not k.startswith("__"):
                        nested_fields.append(StructField(k, self._infer_spark_type(v), True))
                return StructType(nested_fields) if nested_fields else MapType(StringType(), StringType())
            else:
                return StringType()

        def _create_generic_schema(self, entity_config: Dict[str, Any]) -> StructType:
            """Create a generic schema based on entity config."""
            fields = []

            # Add primary keys as non-nullable
            for pk in entity_config.get("primary_keys", []):
                fields.append(StructField(pk, StringType(), False))

            # Add cursor field
            cursor = entity_config.get("cursor_field")
            if cursor and cursor not in [f.name for f in fields]:
                fields.append(StructField(cursor, StringType(), True))

            # Add common audit fields
            audit_fields = ["createdBy", "createdDateTime", "lastModifiedBy"]
            for af in audit_fields:
                if af not in [f.name for f in fields]:
                    fields.append(StructField(af, StringType(), True))

            # Add soft delete field if applicable
            soft_delete_field = entity_config.get("soft_delete_field")
            if soft_delete_field:
                fields.append(StructField(soft_delete_field, StringType(), True))

            return StructType(fields)

        def read_table_metadata(
            self, table_name: str, table_options: Dict[str, str]
        ) -> dict:
            """Get metadata for a table."""
            self._validate_table_name(table_name)

            entity_config = self._ENTITY_REGISTRY[table_name]

            return {
                "primary_keys": entity_config["primary_keys"],
                "cursor_field": entity_config["cursor_field"],
                "ingestion_type": entity_config["ingestion_type"],
            }

        def read_table(
            self, table_name: str, start_offset: dict, table_options: Dict[str, str]
        ) -> Tuple[Iterator[dict], dict]:
            """Read records from a table."""
            self._validate_table_name(table_name)

            entity_config = self._ENTITY_REGISTRY[table_name]
            api_type = entity_config["api_type"]

            if api_type == "odata_v2":
                return self._read_odata_v2(table_name, start_offset, table_options)
            elif api_type == "odata_v4":
                return self._read_odata_v4(table_name, start_offset, table_options)
            elif api_type == "scim_v2":
                return self._read_scim_v2(table_name, start_offset, table_options)
            elif api_type == "rest":
                return self._read_rest(table_name, start_offset, table_options)
            else:
                raise ValueError(f"Unsupported API type: {api_type}")

        def read_table_deletes(
            self, table_name: str, start_offset: dict, table_options: Dict[str, str]
        ) -> Tuple[Iterator[dict], dict]:
            """Read deleted records from a table (for cdc_with_deletes)."""
            self._validate_table_name(table_name)

            entity_config = self._ENTITY_REGISTRY[table_name]

            if entity_config["ingestion_type"] != "cdc_with_deletes":
                raise ValueError(
                    f"Table {table_name} does not support delete synchronization. "
                    f"Ingestion type is: {entity_config['ingestion_type']}"
                )

            api_type = entity_config["api_type"]
            if api_type == "odata_v2":
                return self._read_odata_v2_deletes(table_name, start_offset, table_options)
            else:
                raise ValueError(f"Delete sync not implemented for API type: {api_type}")

        # ==========================================================================
        # OData v2 Implementation
        # ==========================================================================

        def _read_odata_v2(
            self, table_name: str, start_offset: dict, table_options: Dict[str, str]
        ) -> Tuple[Iterator[dict], dict]:
            """Read records from OData v2 API."""
            entity_config = self._ENTITY_REGISTRY[table_name]
            path = entity_config["path"]
            cursor_field = entity_config["cursor_field"]

            params = {
                "$format": "json",
                "$top": str(self.page_size),
                "$inlinecount": "allpages",
            }

            skip = start_offset.get("skip", 0) if start_offset else 0
            if skip > 0:
                params["$skip"] = str(skip)

            cursor = start_offset.get("cursor") if start_offset else None
            filters = []

            if cursor and cursor_field:
                filters.append(f"{cursor_field} gt datetime'{cursor}'")

            custom_filter = table_options.get("custom_filter")
            if custom_filter:
                filters.append(f"({custom_filter})")

            if filters:
                params["$filter"] = " and ".join(filters)

            select = table_options.get("$select")
            if select:
                params["$select"] = select

            expand = table_options.get("$expand")
            if expand:
                params["$expand"] = expand

            if cursor_field:
                params["$orderby"] = f"{cursor_field} asc"

            url = f"{self.base_url}{path}"

            try:
                response = self._make_request_with_retry("GET", url, params=params)
                data = response.json()
            except requests.HTTPError as e:
                if e.response.status_code in (403, 404):
                    logger.warning(f"Table {table_name} not accessible (HTTP {e.response.status_code}). Returning empty result.")
                    return iter([]), start_offset or {}
                raise

            records = data.get("d", {}).get("results", [])
            clean_records = [self._clean_odata_record(r) for r in records]

            records_returned = len(clean_records)
            next_offset = dict(start_offset) if start_offset else {}
            next_offset["skip"] = skip + records_returned

            if clean_records and cursor_field:
                last_cursor = clean_records[-1].get(cursor_field)
                if last_cursor:
                    next_offset["cursor"] = last_cursor

            return iter(clean_records), next_offset

        def _read_odata_v2_deletes(
            self, table_name: str, start_offset: dict, table_options: Dict[str, str]
        ) -> Tuple[Iterator[dict], dict]:
            """Read soft-deleted records from OData v2 API."""
            entity_config = self._ENTITY_REGISTRY[table_name]
            path = entity_config["path"]
            cursor_field = entity_config["cursor_field"]
            soft_delete_field = entity_config.get("soft_delete_field", "mdfSystemRecordStatus")
            soft_delete_value = entity_config.get("soft_delete_value", "D")

            params = {
                "$format": "json",
                "$top": str(self.page_size),
                "$inlinecount": "allpages",
            }

            skip = start_offset.get("skip_deletes", 0) if start_offset else 0
            if skip > 0:
                params["$skip"] = str(skip)

            filters = [f"{soft_delete_field} eq '{soft_delete_value}'"]

            cursor = start_offset.get("cursor") if start_offset else None
            if cursor and cursor_field:
                filters.append(f"{cursor_field} gt datetime'{cursor}'")

            params["$filter"] = " and ".join(filters)

            if cursor_field:
                params["$orderby"] = f"{cursor_field} asc"

            url = f"{self.base_url}{path}"

            try:
                response = self._make_request_with_retry("GET", url, params=params)
                data = response.json()
            except requests.HTTPError as e:
                if e.response.status_code in (403, 404):
                    logger.warning(f"Table {table_name} deletes not accessible. Returning empty result.")
                    return iter([]), start_offset or {}
                raise

            records = data.get("d", {}).get("results", [])
            clean_records = [self._clean_odata_record(r) for r in records]

            records_returned = len(clean_records)
            next_offset = dict(start_offset) if start_offset else {}
            next_offset["skip_deletes"] = skip + records_returned

            if clean_records and cursor_field:
                last_cursor = clean_records[-1].get(cursor_field)
                if last_cursor:
                    next_offset["cursor"] = last_cursor

            return iter(clean_records), next_offset

        # ==========================================================================
        # OData v4 Implementation
        # ==========================================================================

        def _read_odata_v4(
            self, table_name: str, start_offset: dict, table_options: Dict[str, str]
        ) -> Tuple[Iterator[dict], dict]:
            """Read records from OData v4 API using @odata.nextLink pagination."""
            entity_config = self._ENTITY_REGISTRY[table_name]
            path = entity_config["path"]
            cursor_field = entity_config["cursor_field"]

            # Check for continuation URL from previous batch
            next_link = start_offset.get("nextLink") if start_offset else None

            if next_link:
                url = next_link
                params = {}
            else:
                url = f"{self.base_url}{path}"
                params = {
                    "$top": str(self.page_size),
                    "$count": "true",
                }

                cursor = start_offset.get("cursor") if start_offset else None
                filters = []

                if cursor and cursor_field:
                    filters.append(f"{cursor_field} gt {cursor}")

                custom_filter = table_options.get("custom_filter")
                if custom_filter:
                    filters.append(f"({custom_filter})")

                if filters:
                    params["$filter"] = " and ".join(filters)

                select = table_options.get("$select")
                if select:
                    params["$select"] = select

                if cursor_field:
                    params["$orderby"] = f"{cursor_field} asc"

            try:
                response = self._make_request_with_retry("GET", url, params=params if not next_link else None)
                data = response.json()
            except requests.HTTPError as e:
                if e.response.status_code in (403, 404):
                    logger.warning(f"Table {table_name} not accessible. Returning empty result.")
                    return iter([]), start_offset or {}
                raise

            # OData v4 format: records in "value" array
            records = data.get("value", [])
            clean_records = [self._clean_odata_record(r) for r in records]

            # Build next offset
            next_offset = dict(start_offset) if start_offset else {}

            # Check for @odata.nextLink for more pages
            odata_next_link = data.get("@odata.nextLink")
            if odata_next_link:
                next_offset["nextLink"] = odata_next_link
            else:
                # No more pages - remove nextLink if present
                next_offset.pop("nextLink", None)

            # Update cursor
            if clean_records and cursor_field:
                last_cursor = clean_records[-1].get(cursor_field)
                if last_cursor:
                    next_offset["cursor"] = last_cursor

            return iter(clean_records), next_offset

        # ==========================================================================
        # SCIM 2.0 Implementation
        # ==========================================================================

        def _read_scim_v2(
            self, table_name: str, start_offset: dict, table_options: Dict[str, str]
        ) -> Tuple[Iterator[dict], dict]:
            """Read records from SCIM 2.0 API using ID-based pagination."""
            entity_config = self._ENTITY_REGISTRY[table_name]
            path = entity_config["path"]
            cursor_field = entity_config.get("cursor_field")

            # SCIM uses startId/count pagination (preferred) or startIndex/count
            start_id = start_offset.get("startId", "initial") if start_offset else "initial"

            params = {
                "startId": start_id,
                "count": str(self.page_size),
            }

            # Add filter for incremental if cursor exists
            cursor = start_offset.get("cursor") if start_offset else None
            if cursor and cursor_field:
                # SCIM filter syntax
                params["filter"] = f'{cursor_field} gt "{cursor}"'

            url = f"{self.base_url}{path}"

            try:
                response = self._make_request_with_retry("GET", url, params=params)
                data = response.json()
            except requests.HTTPError as e:
                if e.response.status_code in (403, 404):
                    logger.warning(f"Table {table_name} not accessible. Returning empty result.")
                    return iter([]), start_offset or {}
                raise

            # SCIM format: records in "Resources" array
            records = data.get("Resources", [])

            # Build next offset
            next_offset = dict(start_offset) if start_offset else {}

            # Check for nextId (ID-based pagination)
            next_id = data.get("nextId")
            if next_id and next_id != "end":
                next_offset["startId"] = next_id
            else:
                # No more pages
                next_offset.pop("startId", None)

            # Update cursor from meta.lastModified
            if records and cursor_field:
                last_record = records[-1]
                meta = last_record.get("meta", {})
                last_modified = meta.get("lastModified")
                if last_modified:
                    next_offset["cursor"] = last_modified

            return iter(records), next_offset

        # ==========================================================================
        # REST API Implementation
        # ==========================================================================

        def _read_rest(
            self, table_name: str, start_offset: dict, table_options: Dict[str, str]
        ) -> Tuple[Iterator[dict], dict]:
            """Read records from REST API."""
            entity_config = self._ENTITY_REGISTRY[table_name]
            path = entity_config["path"]
            method = entity_config.get("method", "GET")

            url = f"{self.base_url}{path}"

            # For POST-based APIs like TimeAccountBalance, build request body
            if method == "POST":
                # Build request body from table_options
                body = {}
                if "userId" in table_options:
                    body["userId"] = table_options["userId"]
                if "timeAccountType" in table_options:
                    body["timeAccountType"] = table_options["timeAccountType"]
                if "asOfDate" in table_options:
                    body["asOfDate"] = table_options["asOfDate"]

                try:
                    response = self._make_request_with_retry("POST", url, json_data=body)
                    data = response.json()
                except requests.HTTPError as e:
                    if e.response.status_code in (403, 404):
                        logger.warning(f"Table {table_name} not accessible. Returning empty result.")
                        return iter([]), start_offset or {}
                    raise

                # REST APIs typically return results directly or in a wrapper
                if isinstance(data, list):
                    records = data
                elif isinstance(data, dict):
                    records = data.get("results", data.get("value", [data]))
                else:
                    records = []

                # REST snapshot tables don't track cursor
                return iter(records), start_offset or {}

            else:  # GET
                params = {}

                # Handle pagination parameters from table_options
                if "page" in table_options:
                    params["page"] = table_options["page"]
                if "pageSize" in table_options:
                    params["pageSize"] = table_options["pageSize"]

                try:
                    response = self._make_request_with_retry("GET", url, params=params)
                    data = response.json()
                except requests.HTTPError as e:
                    if e.response.status_code in (403, 404):
                        logger.warning(f"Table {table_name} not accessible. Returning empty result.")
                        return iter([]), start_offset or {}
                    raise

                if isinstance(data, list):
                    records = data
                elif isinstance(data, dict):
                    records = data.get("results", data.get("value", [data]))
                else:
                    records = []

                return iter(records), start_offset or {}

        # ==========================================================================
        # HTTP Helper Methods
        # ==========================================================================

        def _make_request_with_retry(
            self,
            method: str,
            url: str,
            params: Optional[Dict] = None,
            json_data: Optional[Dict] = None,
        ) -> requests.Response:
            """Make HTTP request with retry logic and exponential backoff."""
            last_exception = None

            for attempt in range(self.MAX_RETRIES):
                try:
                    response = self._session.request(
                        method=method,
                        url=url,
                        params=params,
                        json=json_data,
                        timeout=60,
                    )

                    if response.status_code == 429:
                        retry_after = int(response.headers.get("Retry-After", 60))
                        logger.warning(f"Rate limited. Sleeping for {retry_after} seconds.")
                        time.sleep(retry_after)
                        continue

                    response.raise_for_status()
                    return response

                except requests.RequestException as e:
                    last_exception = e
                    if attempt < self.MAX_RETRIES - 1:
                        sleep_time = self.RETRY_DELAY_SECONDS * (2 ** attempt)
                        logger.warning(
                            f"Request failed (attempt {attempt + 1}/{self.MAX_RETRIES}). "
                            f"Retrying in {sleep_time}s. Error: {e}"
                        )
                        time.sleep(sleep_time)

            raise last_exception

        def _clean_odata_record(self, record: dict) -> dict:
            """Remove OData metadata from a record."""
            if not isinstance(record, dict):
                return record

            cleaned = {}
            for key, value in record.items():
                if key.startswith("__"):
                    continue

                if isinstance(value, dict):
                    if "__deferred" in value:
                        continue
                    cleaned[key] = self._clean_odata_record(value)
                elif isinstance(value, list):
                    cleaned[key] = [
                        self._clean_odata_record(item) if isinstance(item, dict) else item
                        for item in value
                    ]
                else:
                    cleaned[key] = value

            return cleaned

        # ==========================================================================
        # Validation Helpers
        # ==========================================================================

        def _validate_table_name(self, table_name: str) -> None:
            """Validate that table_name is in the supported list."""
            if table_name not in self._ENTITY_REGISTRY:
                raise ValueError(
                    f"Table '{table_name}' is not supported. "
                    f"Available tables: {len(self._ENTITY_REGISTRY)} entities. "
                    f"Use list_tables() to see all supported tables."
                )

        # ==========================================================================
        # Utility Methods
        # ==========================================================================

        def get_tables_by_module(self, module: str) -> List[str]:
            """Get list of tables for a specific module."""
            return self._MODULE_TABLES.get(module, [])

        def get_available_modules(self) -> List[str]:
            """Get list of available modules."""
            return list(self._MODULE_TABLES.keys())


    # Initialize module tables after class is fully defined
    LakeflowConnect._MODULE_TABLES = LakeflowConnect._build_module_tables()


    ########################################################
    # pipeline/lakeflow_python_source.py
    ########################################################

    METADATA_TABLE = "_lakeflow_metadata"
    TABLE_NAME = "tableName"
    TABLE_NAME_LIST = "tableNameList"
    TABLE_CONFIGS = "tableConfigs"
    IS_DELETE_FLOW = "isDeleteFlow"


    class LakeflowStreamReader(SimpleDataSourceStreamReader):
        """
        Implements a data source stream reader for Lakeflow Connect.
        Currently, only the simpleStreamReader is implemented, which uses a
        more generic protocol suitable for most data sources that support
        incremental loading.
        """

        def __init__(
            self,
            options: dict[str, str],
            schema: StructType,
            lakeflow_connect: LakeflowConnect,
        ):
            self.options = options
            self.lakeflow_connect = lakeflow_connect
            self.schema = schema

        def initialOffset(self):
            return {}

        def read(self, start: dict) -> (Iterator[tuple], dict):
            is_delete_flow = self.options.get(IS_DELETE_FLOW) == "true"
            # Strip delete flow options before passing to connector
            table_options = {
                k: v for k, v in self.options.items() if k != IS_DELETE_FLOW
            }

            if is_delete_flow:
                records, offset = self.lakeflow_connect.read_table_deletes(
                    self.options[TABLE_NAME], start, table_options
                )
            else:
                records, offset = self.lakeflow_connect.read_table(
                    self.options[TABLE_NAME], start, table_options
                )
            rows = map(lambda x: parse_value(x, self.schema), records)
            return rows, offset

        def readBetweenOffsets(self, start: dict, end: dict) -> Iterator[tuple]:
            # TODO: This does not ensure the records returned are identical across repeated calls.
            # For append-only tables, the data source must guarantee that reading from the same
            # start offset will always yield the same set of records.
            # For tables ingested as incremental CDC, it is only necessary that no new changes
            # are missed in the returned records.
            return self.read(start)[0]


    class LakeflowBatchReader(DataSourceReader):
        def __init__(
            self,
            options: dict[str, str],
            schema: StructType,
            lakeflow_connect: LakeflowConnect,
        ):
            self.options = options
            self.schema = schema
            self.lakeflow_connect = lakeflow_connect
            self.table_name = options[TABLE_NAME]

        def read(self, partition):
            all_records = []
            if self.table_name == METADATA_TABLE:
                all_records = self._read_table_metadata()
            else:
                all_records, _ = self.lakeflow_connect.read_table(
                    self.table_name, None, self.options
                )

            rows = map(lambda x: parse_value(x, self.schema), all_records)
            return iter(rows)

        def _read_table_metadata(self):
            table_name_list = self.options.get(TABLE_NAME_LIST, "")
            table_names = [o.strip() for o in table_name_list.split(",") if o.strip()]
            all_records = []
            table_configs = json.loads(self.options.get(TABLE_CONFIGS, "{}"))
            for table in table_names:
                metadata = self.lakeflow_connect.read_table_metadata(
                    table, table_configs.get(table, {})
                )
                all_records.append({TABLE_NAME: table, **metadata})
            return all_records


    class LakeflowSource(DataSource):
        def __init__(self, options):
            self.options = options
            self.lakeflow_connect = LakeflowConnect(options)

        @classmethod
        def name(cls):
            return "lakeflow_connect"

        def schema(self):
            table = self.options[TABLE_NAME]
            if table == METADATA_TABLE:
                return StructType(
                    [
                        StructField(TABLE_NAME, StringType(), False),
                        StructField("primary_keys", ArrayType(StringType()), True),
                        StructField("cursor_field", StringType(), True),
                        StructField("ingestion_type", StringType(), True),
                    ]
                )
            else:
                # Assuming the LakeflowConnect interface uses get_table_schema, not get_table_details
                return self.lakeflow_connect.get_table_schema(table, self.options)

        def reader(self, schema: StructType):
            return LakeflowBatchReader(self.options, schema, self.lakeflow_connect)

        def simpleStreamReader(self, schema: StructType):
            return LakeflowStreamReader(self.options, schema, self.lakeflow_connect)


    spark.dataSource.register(LakeflowSource)  # pylint: disable=undefined-variable
